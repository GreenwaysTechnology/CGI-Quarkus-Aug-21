

Tech Stack:
...........

1.Quarkus
2.JEE Standards
3.Spring-Spring Boot Integration On Quarkus
4.Micro Services
     -Micro Profile
         -SmallRye Underlaying framework for Quarkus
5.Cloud Native Architecture
    -Containers
       -Docker
       -Kubernetes
       -openshift

5.12 Factor app standards

6.Ecplise Vertx
   -Non Blocking ,Async Programming

7.Reactive Programming using Rxjava and mutiny

8.GraalVM
..............................................................................................


java -jar myapp.jar (appCode +webcontainer) - dev
    |
container

java -jar myapp.jar - production
  |
 Container
   |
os

myapp.exe
  |
container


Myapp.class------GrallVm-------COnvert assembly(.class) ----->Native Assembly

.............................................................................................
				Application Architectures
...............................................................................................

1.Monolithic
2.Microservice

1.Monollithic Application Development Steps

Properties:

1.Domain - Biz requirement  - Domain Analyist - Collecting Requirement

2.Requirement into Software Specification

Technology:
 Java-JEE

 -Framework -Spring
 -Database - MYsql
 -Middlewares -  RabbitMQ....
 -Dev Server -Tomcat
 -DeploymentServer - JBoss  

3.High Level Design
   Data Modeling
   JEE App Design
    -Web layer ,entity layer,messaging layer


4.Development
    Provisions for dev

5.Testing 
    

6.Production Plan.


Monolithic app work flow will go one by one 


Cons of Monolithic:

1.Requirement can t be freezed in short duration, since biz is dynamic.

2.Tech stack:
  There are many modules in the app, any one of the module need to be development in different
 Technology
  -python,nodejs,Ruby,C#
  -different databases -  sql, nosql,messaging servers

 Vendor-lock

3.Design can be started once req is freezed
  -we have many modules, most of the modules are over, payment module taking much time to freeze.

4.Dev
   Dev cant be started due to req not clear.

5.Test 
   until over testing cant be

6.Deployment - Production
   -The whole app must be ready for deployment.
   -Provisioning
      -database,webservers,middlewares....
..............................................................................................

Common issues:

 we cant move from step 1 to step 2 until step 2 is completed.
 This model is tightly coupled.

We have to start loosly coupled model

1. req is going while you start design, while design is going , start dev, while dev going, start testing , once testing done, start deployment-- Go Live.
 
Domain-driven design is the concept that the structure and language of software code should match the business domain. - Remove Vendor lock

According to DDD -Application has to be broken into separate subdomains.

Each Subdomain can be any, built,test,deploy separtely  :Automation - Continous process : Agil Process.
..............................................................................................
 
Micro Services:

Common ideas

1.Highly maintainable and testable
2.Loosely coupled
3.Independently deployable
4.Organized around business capabilities
5.Owned by a small team

Advantages:

Strong Module Boundaries: Microservices reinforce modular structure, which is particularly
important for larger teams.

• Independent Deployment: Simple services are easier to deploy, and since they are autonomous,
are less likely to cause system failures when they go wrong.

• Technology Diversity: You can mix multiple languages, development frameworks and datastorage
technologies (i.e. each team working on a microservice has more flexibility to employ
different technologies without affecting other teams).
  

Cons of Micro Services:
.......................

• Distribution: Distributed systems are harder to program since remote calls are slow and are
always at risk of failure.
• Eventual Consistency: Maintaining strong consistency is extremely difficult for a distributed system, which means everyone has to manage eventual consistency.
• Operational Complexity: You need a mature operations team to manage lots of services which
are being redeployed regularly.
.............................................................................................
                               Distributed Application Design Patterns
.............................................................................................

Distributed Application Design Pattern: 
-Monolithic
-MicroServices
.............................................................................................
                            Monoloith Design patterns 
.............................................................................................

1.GOF patterns
2.JEE Patterns
   -MVC
   -DAO
   -Service Locator

..............................................................................................
	        Microservices Application Design Patterns
.............................................................................................

Microservices are subdomain driven model.


Data Layer-(Data Management) Design patterns In Microservices:
............................................
1.Database per Service
2.Shared database
3.Saga
4.API Composition
5.CQRS
6.Domain event

7.Event sourcing
...........................................................................................  

		Application Development and its Related Patterns:
...........................................................................................

-Language ----Framework /Lib
-Java:
Style:
  -Object Oriented Programming language
  -Functional Style Programming 

OOP :
 -Object
   -State + Behaviour

What is Service?
  Service is nothing but "offer".
  The Object which offer some features

  OrderService offers order related Features
  -placeOrder
  -findAllOrders
  -findOrderByid
  -updateExistingOrder
  -cancelOrder
  -etc....
What is Micro?
   Smallest 

What is Micro Service?
   Smallest Service in   a domain

Is there is any pattern is avaible to design Service?

Based on SOLID Prinicples

1.Single Responsibility Principle
2.Open/Closed Principle
3.Liskov Substitution Principle
4.Interface Segregation Principle
5.Dependency Inversion

Every service need to designed based on 

 "Single Responsibility Principle" - SRP

How to Represent Service?

 Every Service is Object.

class CreditCardService {

}
class DebitCardService {

}
............................................................................................

Object (Service) Communication:
..............................
Service Communication style Design Pattern

1.Remote Procedure Invocation
2.Messaging
3.Domain-specific protocol
4.Idempotent Consumer
...........................................................................................






























































