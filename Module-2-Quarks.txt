					QuarKus
...........................................................................................
What is QuarKus?

 A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.

In Quarkus you can built  monolithic and micro servies apps which we can run directly on containers(kubernetes) and native(host) machines, on JVM as well.
..............................................................................................

Quarkus Programming Model:

1.Imperative Model
   -It is regular Programming model
2.Reactive Programming Model
   -Using Reactive Specification


Quarkus has been built on Java Specifications.

Types of specifications:

1.JSE -  Java Standard Edition
2.JEE -  Java Enteriprise Edition
3.JME  - Java Micro Edition

Who is offering these specification?

Java Community Process  is non profitable organization.


JCP releases : JSRs: Java Specification Requests

Java EE (54 JSRs)
The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.
The JSRs in this list are part of the Java EE platform as component or umbrella JSRs.

Java SE (69 JSRs)
The Java Standard Edition offers APIs and tools for developing desktop and server-side enterprise applications. The JSRs in this list are part of the Java SE platform as component or umbrella JSRs.

Java ME (85 JSRs)
Java ME technology, Java Micro Edition, specifically addresses the vast consumer space, which covers the range of extremely tiny commodities such as smart cards or a pager all the way up to the set-top box, an appliance almost as powerful as a computer.



JSE :
 -JavaTM Management Extensions (JMXTM) Specification
 -XML Parsing Specification
 -JDBC  Specification
 -Concurrency Utilities
- JSR-000384 JavaTM SE 11

Java EE (54 JSRs) :Quarkus has been built on the top of JEE Specification
-XML Parsing Specification
-Enterprise JavaBeans
-Java Servlet Spec
-JPA Spec
-JSON-B Spec
-Bean Validation
WebServices:
-JAX-RS - Building Resfull API
-JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
-JTA 
 -Container Specs 
    How to create Enterprise grade applications and how to deploy them
 JBOss,tomcat,weblogic,websphere are products based on contaner specs

Spec implementations:
-Frameworks like spring
-containers like tomcat,jboss,weblogic....

.............................................................................................
			Are we using JEE Spec and its implementations on a now days
.............................................................................................
                                         No!

Why JEE Spec failed In Modern Computing?
  
   JEE Spec was developed to build traditional Monolothic distributed,transactional, secure 
Applications


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

		Birth of Project called "MicroProfile"


MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.
Eclipse MicroProfile addresses the need for enterprise "java MicroService"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards

MicroProfile Implementations:
.............................

Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
...............................................................................................
                 Quarkus is built on top of various projects and standards

                Quarkus is built on Core JEE Standards and MicroProfile Standards


1.RestEasy  - framework built for JAX-RS Spec for building REST APIS
2.Hibernate and JPA  -Data Layer
3.Ecplise Micro Profile spec via SmallRye Framework

SmallRye Config
	An implementation of MicroProfile Config

SmallRye JWT
	An implementation of MicroProfile JWT RBAC

SmallRye Health
	An implementation of MicroProfile Health

SmallRye Fault Tolerance
	An implementation of MicroProfile Fault Tolerance

SmallRye Metrics
	An implementation of MicroProfile Metrics

SmallRye OpenAPI
	An implementation of MicroProfile OpenAPI

SmallRye OpenTracing
	An implementation of MicroProfile OpenTracing

RESTEasy REST Client
	An implementation of MicroProfile REST Client

4.Apache Camel

5.Reactive Programming via Rxjava and mutiny

6.Container  - Non blocking container -Netty

7.Web Container Nettty and Vertx Engine

etc.....

Container integration - kubernetes
Cloud Integration
.............................................................................................
                                    Quarkus Project Setup
..............................................................................................

Quarkus Build System:
 - Maven
 - Gradle

Software Req:

1.GrallVm
2.jdk 11
3.maven/gradle
4.IntelliJ idea / vscode
5.Docker

/////////////////////////////////////////////////////////////////////////////////////////////


Quarkus : First App


how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project creations

Way -1

mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"

cd getting-started


Way-2 :Interactive way to create Project
mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create 

Way-3 : via web portals

https://code.quarkus.io/

Way -4 : ide plugins
 via Intellij idea plugins


Running Quarkus :

1.Dev
2.Test
3.Production


How to write and Run Application?

Dev:
 ./mvnw compile quarkus:dev - linux /mac

 mvnw compile quarkus:dev  - windows

 mvn compile quarkus:dev

Dev features;

-Live coding Reloading
   if write code and save and referesh your browser / any tool

.............................................................................................

Run Application:

1.With JVM
  -Running app on JVM either in host machine or virtualized env - vms and containers
You need jar file

2.Without JVM
 -Running Application  directly  on host operating system or inside vms/containers


1.With JVM

jar file creation.

1.normal jar
2.fat jar / uber jar

Fat JAR:
A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies). ... Fat JARs are handy when you need to build an executable JAR file, e.g. a microservice executable

Packaging and running the application

The application can be packaged using:

```shell script
./mvnw package
```
It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.
Be aware that it‚Äôs not an _√ºber-jar_ as the dependencies are copied into the `target/quarkus-app/lib/` directory.

If you want to build an _√ºber-jar_, execute the following command:
```shell script
./mvnw package -Dquarkus.package.type=uber-jar
```

The application is now runnable using `java -jar target/quarkus-app/quarkus-run.jar`.


Lab Side :

1.Build normal jar  and test 
  $java -jar target/quarkus-app/quarkus-run.jar

2.Build fat 
./mvnw package -Dquarkus.package.type=uber-jar
The application is now runnable using 
$java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar

.............................................................................................

With JVM:

Native App:

How to convert Quarkus app into native binary and run ? without JVM


How to build Native Image?

There are multiple patterns

1.With installed GRALLVM Software

mvnw package -Pnative
    

GrallVM - BUild image - on os - myos1.0 -----

GrallVM - BUild image  myos2.0 ----


Note: 

if you are building image on windows

1.You must have installed GrallVm software before builiding image other wise it will throw error

Error: Default native-compiler executable 'cl.exe' not found via environment variable PATH
Error: To prevent native-toolchain checking provide command-line option -H:-CheckToolchain
com.oracle.svm.core.util.UserError$UserException: Default native-compiler executable 'cl.exe' not found via environment variable PATH
To prevent native-toolchain checking provide command-line option -H:-CheckToolchain

Please follow the url for installing grallvm in your local windows desktop:

https://www.graalvm.org/docs/getting-started/windows/

if you building image on linux

2.You must have installed GrallVM software on Linux

if you want to convert 

...................................................................................

Building Native Image using Docker 

mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker
..............................................................................................
				  GraallVM	
.............................................................................................

What is GraalVM?
  GraalVM is the next generation compiler to compile java and other code into native binary
to achive language interoperability.

GRALLVM provides a compiler call "Grall" 

 Grall is extension compiler works along with JVM - HOT SPOT

java  --grall App

GrallVM provides lot of tools to work with native images and other language

1.sulong: 
  Memory manager
2.Truffle Framework
   Language framework to run java like apps with out jvm,node,phython runtimes.
3.Grall Compiler  
    supports compiling java code statically, dynamically
4.JVM COMPILER interface
    to plugg grall compiler along with existing javac compiler
5.Java hotpot jvm
    Grallvm compiler + hot Spot + JIT + AOT

.......................................................................................
			      JVM
Hello.java -->Hello.class--|--ClassLoader---|SM---|init---|invokeDynamic---|Refelcetion,proxy| --|Class Object(meta Object)-----instance Creation---lives in memory-heap---


Mandrel
Mandrel is a downstream distribution of the GraalVM community edition. Mandrel's main goal is to provide a native-image release specifically to support Quarkus. 
The aim is to align the native-image capabilities from GraalVM with OpenJDK and Red Hat Enterprise Linux libraries to improve maintainability for native Quarkus applications.
.........................................................................................

Lab: Set up GraalVM : How to build native image?

Steps:

1.sudo apt-get update 

2.sudo apt-get install gcc zlib1g-dev build-essential

3.wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-21.0.0.2/graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

4.tar -xvzf graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

5.ls

6.sudo mkdir /usr/lib/jvm 
7.sudo mv graalvm-ce-java11-21.0.0.2/ /usr/lib/jvm

8.echo 'export PATH=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2/bin:$PATH' >> ~/.bashrc


9.echo 'export JAVA_HOME=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2' >> ~/.bashrc

10.logout

11.source ~/.bashrc

12.java -version 
13.gu install native-image
14.gu available 
15.javac HelloWorld.java
16.native-image HelloWorld
17.ls
./helloworld
.............................................................................................
How to Run  Quarkus Application?


1.Dev Mode
  mvnw compile

2.Production Mode

-Running on JVM On host
  -using Jar patterns
-Running on JVM On Container which run on Host/Cloud

-Running on Host without JVM
   -Using Native Image
How to build native Image out of Quarks App

- Build native binary using Docker Container, Here docker is build system to build native
   mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

-Build native binary using GrallVM Itself.

 mvnw package -Pnative

 To run this command we need GraalVM setup must be there in host machine or where we are building binary.

.............................................................................................

Lab : 

- create simple project

-Run
 -dev
package
 - jar
 -uber jar
 -native image
    -using docker build
         mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

    -using graalvm native build
	mvnw package -Pnative

/home/ramya/myquarkusapps / getting-started
..............................................................................................
					Quarkus Modules
..............................................................................................

Modules:

1.core
2.web
3.data
4.microservies
5.cloud
6.security
..............................................................................................
					Web Module
..............................................................................................

Web Module : 

 Restfull Web Services : HTTP based Micro Services

Quarkus has been built on JEE Standards

Web Service Standards:

1.JAX-RS - Building Restfull api 
2.JAX-WS - SOA -Soap and XML based Web Services

JAX-RS 
 Spec Doc url : https://download.oracle.com/otn-pub/jcp/jaxrs-2_0-fr-eval-spec/jsr339-jaxrs-2.0-final-spec.pdf?AuthParam=1628233398_2da58a3072d802256d822163050b633f

Apache RestEasy Framework which implements JAX-RS spec.

Apache RestEasy implements even MicroProfile Spec as well
 -Config Spec
 -WebClient Spec

Quarkus abstracts or implements Apache RestEasy implementation.


maven Dependancy:
<dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy</artifactId>
</dependency>

RESTFull WebServices:
.....................

Representational State Transfer (REST)


Representational :
  The Data Format.
  Data is encaspulted inside object , object can be transfered into format and send over network.

  Java Object -----|XML /JSON(Representation)------send over network-----|Parsing---| Object

   Object to String
   String to Object


State : 
   Object state - OBject data

Transfer 
  Moving from one place to another.

.............................................................................................

How to begin Restfull Web Service based distributed App?

1.Identifying Model(Object)-Domain Object

 eg:
  Customer,Order,Inventory,Products,Items

2.Resources
   
    Program, having apis , gets exectued when ever request comes for accessing object.

 In java Resource is class.

   public class OrderResource{

   }
   public class CustomerResource{

   }

    public class ProductResource{

   }

Coding Standard according jax-rs spec

  Any resource class must be 
  
  -meaningfull to the domain model
     Order
  -Noun
      Order
  -Should have suffix Resource
      OrderResource  
  

3.Model URI

 URI - Uniform Resource Identifier.

 /api/orders
 /api/customers
 /api/orders/1
 /api/products/1
 

Client(Could be  humman being or anythoer system(app)) wants data from Distributed System.

Client-----------request(want)---------System---Running on Another Software(WebContainer)---Runs Resources

HTTP Protocal:
..............

What is Protocal?

  In Computer, where ever you transfer data , there is protocal.

http://identification:port/resource/subreource
https://
jdbc://
soap://
c:/
ftp://
 |
scheme

 
What is HTTP Protocal?
  
 It is set of rules for transfering web documents(html,img,videos,docs,pdf,json,xml) over internet.
  -Type of web document identified by - application/xxx - Media Type

How to represent http protocal?
  
is it software /hardware?

HTTP is Program written in C langauge

HTTP Program types

1.HttpRequest.c
2.HttpResponse.c
3.HttpSocket.c

Program contain two things:

1.Variables 
2.Methods/functions

HTTP Program also contains 

variables
    - HTTP headers - content-type,auth,cookie,date.....
methods
    - functions are called HTTP methods

 get,post,put,delete,trace,options,head............

 void main(){

     int * get(args) {
	logic.... for get-- read operations
     }
 }

Web Server:
  It is program which calls http functions

Flow of HTTP

Client GET /api/resource----------------|WebServer----function get() { 
							return "something" // response
						       }


HTTP Programming Models:

In 1996, Many Companies wanted to abstract http  layer to build http driven distributed apps

- J2EE -  Servlet--- Abstraction on HTTP Core apis
- ASP - Microsoft
- PHP

REST also uses exsiting http arch.

JAX-RS is spec to design REST based web app using annotations.


JAX-RS Annotations:

1.Resource Identifier
 
@Path

2.HTTP Method Binding
 
@GET,@POST,@PUT,@DELETE,@TRACE



REST Resource:

package org.cgi.getting.started;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/hello")
public class GreetingResource {
    @GET
    public String sayHello() {
        return "Hello";
    }
}

PATH Design
Responses
Negotiation

 -Content - json,xml...
 -Language
 -Encoding
..............................................................................................

HTTP Resources and Methods:
...........................

Use case :  How to design Resource with HTTP methods.


@Path:

 -Annotation can be used at class Level - Root Resource
 -Annotation can be used at method level - Nested Resource

/mainresource/subresource
  |             |
class         method

GET:
  GET is a read-only operation. 
  It is used to query the server for specific information.
  It is both an idempotent and safe operation. 

Idempotent means that 
  no matter how many times you apply the operation, the result is always the same.

Safe means that
invoking a GET does not change the state of the server at all. This means that, other
than request load, the operation will not affect the server.




Client asks that give me some thing (document,image,pdf,data).

Client sends request(instruction)----------http----------------|WebServer - will call method 							-Get Method(function)---will do some 							 io operation --read image file----
							 Write into outputstream(response)
Client will Recive Response <-----------------------------------------
    


Every Resource must have mapped at least one http method mapping.


package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }
}


Without @GET, it will cause an error.

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    
    public String getUser(){
        return "Subramanian";
    }
}

What if a uri points multiple methods having Same Request HTTP Method.

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    public String getInfo(){
        return "Info";
    }
}

Look at console
2021-08-09 13:42:48,400 WARN  [org.jbo.res.res.i18n] (executor-thread-0) RESTEASY002142: Multiple resource methods match request "GET /users". Selecting one. Matching methods: [public java.lang.String com.cgi.rest.UserResource.getUser(), public java.lang.String com.cgi.rest.UserResource.getInfo()]

Resoult would be last method result.

info

How to use @Resource at method level and class Level

package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }
}

What if @Path is not used at class level?

package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

public class UserResource {

    @GET
    @Path("/users")
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }
}

//http://localhost:8080/users

We will get 404 -Resource Not Found Error.
..........................................................................................

PUT:
    Requests that the server store the message body sent with the request under
the location provided in the HTTP message.

It is usually modeled as an insert or update.
It is also idempotent.

POST
    POST is the only nonidempotent and unsafe operation of HTTP.

Each POST method is allowed to modify the service in a unique way.
You may or may not send information with the request.
You may or may not receive information from the response.

DELETE
  DELETE is used to remove resources. 
  It is idempotent as well.


HEAD
  HEAD is exactly like GET except that instead of returning a response body, it
returns only a response code and any headers associated with the request.

OPTIONS

 OPTIONS is used to request information about the communication options of the
resource you are interested in. 
It allows the client to determine the capabilities of a server and a resource without triggering any resource action or retrieval.


package com.cgi.rest;

import javax.ws.rs.*;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }

    @PUT
    public String updateUser(){
        return "Updated";
    }

    @POST
    public String save(){
        return  "saved";
    }
    @DELETE
    public String remove(){
        return "Removed";
    }
}
..............................................................................................
				  JAX-RS Injection
.............................................................................................

What is injection?

 JAX-RS is pulling information from an HTTP request and injecting it into a java method.

We can get information after injection

-Fragement of incoming URI
-QueryString in a URI.
-The client might be sending some critical HTTP headers(request Header) or cookie values.

How to inject jax-rs annotations.

-@PathParam
-@MatrixParam
-@QueryParam
-@HeaderParam
-@FormParam
-@CookieParam
-@Context


@PathParam: 
  is used to form dynamic URI
/products/1 - here 1 is dynamic
i want to return product information having id 1.

@Path("{id}")
@Path("/products/{id}")


Use case : how to use path param , inject pathparam and read values
package com.cgi.res.params.path;


import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/library")
public class LibraryResource {

    @GET
    public String getBooks(){
        return "Books";
    }

    //library/book/123345
    @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") String isbn){
        return "Book by isbn" + isbn;
    }
   
}

Use case : if path param uri looks like different but which shares same url pattern

Note : Method Selection always based on URL Patterns not method signature


  @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") int isbn){
        return "Book by isbn" + isbn;
    }
    @GET
    @Path("/book/{authorName}")
    public String getAuthor(@PathParam("authorName") String authorName){
        return "Author - " + authorName;
    }

This code will match always the first one , second one will be skipped.

package com.cgi.res.params.path;


import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/library")
public class LibraryResource {

    @GET
    public String getBooks(){
        return "Books";
    }

    //library/book/123345
    @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") int isbn){
        return "Book by isbn" + isbn;
    }
    @GET
    @Path("/book/author/{authorName}")
    public String getAuthor(@PathParam("authorName") String authorName){
        return "Author - " + authorName;
    }
}
.............................................................................................
			    Path Design using Regular Expressions
.............................................................................................

Regular expression is one of the most popular text processing patterns

https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html


The @Path template variable is not limited to a fixed string expression, we can also use regular expressions for them. The regex must be a valid expression per Java regex specs.

By default, the URI variable must match the regular expression "[^/]+?".

That means a path of one or more characters value will match, also the leading '/' is always ignored, so it's not necessary to always put a leading '/' in path variable names.

Syntax for using regex
@Path("fixedPart/{variable: regex}")

The following example restrict user name to be only of lowercase and uppercase alphanumeric characters.

@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")


package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("/users")
public class UserResource {

    /**
     *@Path("list/{userName:[a-zA-Z][a-zA-Z_0-9]*}")
     * valid urls
     * localhost:8080/users/list/Subramanian
     * localhost:8080/users/list/SUBRAMANIAN
     * localhost:8080/users/list/SUBRAM12333ANIAN
     *  @Path("list/{userName:[a-zA-Z]*}")
     *  valid urls:
     *  localhost:8080/users/list/SUBRAMANIAN
     */
    @GET
    //@Path("list/{userName:[a-zA-Z][a-zA-Z_0-9]*}")
    @Path("list/{userName:[a-zA-Z]*}")
    public String getUser(@PathParam("userName") String userName) {
        return "User Name Regex" + userName;
    }
}
.............................................................................................
				    Query Parameters
.............................................................................................

@QueryParam :
 It is used to read request parameter which was supplied via Query Strings

 GET /books?num=5
 GET /customers?start=1&size=10
package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;

@Path("/queryresource")
public class QueryParamResource {

//localhost:8080/queryresource?num=10&start=1&size=100
    @GET
    public String getQueryParam(@QueryParam("num") int num, @QueryParam("start") int start, @QueryParam("size") int size) {
        return "Query Params" + num + " " + start + " " + size;
    }
}
........................................................................
What if i have more parameters? i have to inject into method in order to access all parameters
We have short cut to read all parameters using One Object.
............................................................................................
				  Context Object
............................................................................................

Context Object represents "container". Using context object we can access many information.

Information:

javax.ws.rs.core
1.HttpHeaders
2.UriInfo
3.Request
4.HttpServletRequest - ServletRequest
5.HttpServletResponse
6.ServletConfig
7.ServletContext
8.SecurityContext
............................................................................................
                             Accssing Query Params using Context
.............................................................................................


package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.UriInfo;

@Path("/queryresource")
public class QueryParamResource {
    @GET
    public String getQueryParam(@QueryParam("num") int num, @QueryParam("start") int start, @QueryParam("size") int size) {
        return "Query Params" + num + " " + start + " " + size;
    }

    //localhost:8080/queryresource/ctx?num=10&start=1&size=100
    @GET
    @Path("ctx")
    public String getQueryParamUsingContext(@Context UriInfo uriInfo){
        String num = uriInfo.getQueryParameters().getFirst("num");
        String start =uriInfo.getQueryParameters().getFirst("start");
        String size = uriInfo.getQueryParameters().getFirst("size");
        return "Query Params using ctx " +  num + " " + start + " " + size;
    }
}
..............................................................................................
				 Matrix Parameters

Matrix Parameter is used along with Path Parameter, in order to add more values for given path.

Car Information:

/car/{make}/{model}/{year}

/car/mercedes/e55;color=black/2008
		    |
		 Matrix Parameter

To read Matrix Parameter value @MatrixParam("color") String color

package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.MatrixParam;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("/car/{make}")
public class CarResource {

    //localhost:8080/car/mercedes/e55;color=black/2008
    @GET
    @Path("/{model}/{year}")
    public String getCarInfo(@MatrixParam("color") String color,
                             @PathParam("make") String make,
                             @PathParam("model") String model,
                             @PathParam("year") String year
    ) {

        return "Car " + color + make + model + year;
    }
}
..............................................................................................
				Header Parameter
                                  @HeaderParam

This annotation is used to inject http request header values.
For eg : Server is interested to know or read all client http request headers
like content type,accept,language,encoding,client details....

package com.cgi.rest.params;

import org.jboss.resteasy.annotations.jaxrs.HeaderParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import java.util.Set;

@Path("/headers")
public class HeaderParamResource {

    @GET
    public String getHeaderInfo(@HeaderParam("Content-Type") String contentType ,@HeaderParam("Accept") String acceptType){
            return "Header" + contentType + " " + acceptType;
    }
    @GET
    @Path("/all")
    public String getAllHeaders(@Context HttpHeaders httpHeaders){
        //print only headers and not values - keySet returns only key portion
        httpHeaders.getRequestHeaders().keySet().forEach(header->{
            System.out.println(header);
        });
         return "all";
    }
}
.................................................................................................
				Cookie Params
.............................................................................................

if you want to read cookie and send cookie

we can use @CookieParam to read cookie value.

cookie is used to exchange information between client and server for unquie identification.


Steps:

1.Server should send cookie to the client

2.Client should send the same cookie to the server
  
From the server , if i want read cookie sent by client -@CookieParam 

package com.cgi.rest.params;

import javax.ws.rs.CookieParam;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.NewCookie;
import javax.ws.rs.core.Response;

@Path("/login")
public class CookieParamResource {

    //send cook
    @GET
    @Path("/createcookie")
    public Response createCookie(@QueryParam("userName") String userName) {
//        NewCookie cookie = new NewCookie("userName", "Subramanian");
        NewCookie cookie = new NewCookie("userName", userName);

        //send cookie to the client
        return Response.ok("cookie sent").cookie(cookie).build();
    }

    @GET
    public String getCookie(@CookieParam("userName") String userName) {
        return "Cookie Name " + userName;
    }

}
.............................................................................................
				 Sending Data via Forms
.............................................................................................


Form data can be sent to the server , via "Payload-body".

When the input request body is of the type "application/x-www-form-urlencoded" , aka html form,you can collect data into one single payload looks like an object, send to the the server.

Now server can extract form parameters from the "Payload" using @FormParam

<form method="post" action="resource/form">
   <input type="text" name="firstName">
   <input type="text" name="lastName">
</form>
We are going to use post man to send form data.


package com.cgi.rest.params;

import javax.ws.rs.FormParam;
import javax.ws.rs.POST;
import javax.ws.rs.Path;

@Path("/register")
public class RegisterationFormResource {


    @POST
    @Path("/save")
        public String save(@FormParam("firstName") String firstName, @FormParam("lastName") String lastName) {
        return "Form saved" + firstName + lastName;
    }

}
...........................................................................................
				 @DefaultValue
...........................................................................................
@DefaultValue is a parameter annotation that can be combined with any of the other @*Param
annotations to define a default value when the HTTP request item does not exits.

eg:

GET /book?num=10 

public ReturnType getBook(@QueryParam("num") int num) {


}

package com.cgi.rest.params;

import javax.ws.rs.*;

@Path("/book")
public class DefaultParamResource {

    @GET
    public String getQueryParam(@QueryParam("num") @DefaultValue("10") int num) {
        return "Query " + num;
    }

//    @GET
//    @Path("{id}")
//    public String getPathParam(@PathParam("id") @DefaultValue("100") int id) {
//        return id + "";
//    }
}
.............................................................................................
			        Resource Locators and Sub Resources
............................................................................................

Main resource:

ShoppingApp.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.Path;

@Path("/cgi/api")
public class ShoppingApp {

    @Path("/customers")
    public CustomerResource getCustomer() {
        return new CustomerResource();
    }

    @Path("/payments")
    public PaymentResource getPayment() {
        return new PaymentResource();
    }
}

CustomerResource.java
package com.cgi.rest.resourcelocators;


import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class CustomerResource {

    @GET
    public String getCustomers() {
        return "customers resource";
    }

    @GET
    @Path("{id}")
    public String getCustomerById(@PathParam("id") String id) {
        return "customers resource by id" + id;
    }
}

PaymentResource.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class PaymentResource {
    @GET
    public String getPayment() {
        return "Payment resource";
    }

    @GET
    @Path("{id}")
    public String getPayment(@PathParam("id") String id) {
        return "Payment resource by id" + id;
    }

    @Path("/creditcard")
    public CreditCardResource getCreditCard(){
          return new CreditCardResource();
    }

}

CreditCardResource.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.GET;

public class CreditCardResource {
    @GET
    public String getCreditCardDetails() {
        return "Credit Details";
    }
}
..............................................................................................

How to send data(information) to Server?

1.via Parameters - path,query,matrix,cookie,headers
2.via forms - payload(body)
3.via payloads- submit xml,json...

-Responses
-Negotation
-Exception
..............................................................................................
				   Responses

What is Response?
    
 Information + its Meta Data
 
Information can be any thing from data to static files(image,vid,docs)...

Information if it is state of the resource eg - customer,product,payment.....

As Per REST concept, Server can send any type of Format approvied by Rest spec.

eg Json,xml,html,plain text,image.......


Meta Data : data about data:
...........................

Headers - carry meta data.

Response code -  can be success,failure....
Data type(contentType/media type)- plaintext ,html,xml,json.........

.............................................................................................

RestEasy can return data using String,Domain Object,Response Object


@GET
public String getInfo(){ 
     
    return "Hello"  //Plain Text /Ascii Text
}

@GET
public Customer getCustomer(){ 
     
    return new Customer();  Object need to converted into String form(Special String types- 			    XML,JSON)
}


@GET
public Response getCustomer(){ 
     
    return Response.status.(200).ok(new Customer()).build()
       //Here you can add more and more meta information as part of Response
				  
}
............................................................................................

If you are getting the error like below, when you access an resource

Could not find MessageBodyWriter for response object of type: com.cgi.rest.responses.User of media type:application/octet-stream

Server says, hey i am not able to process your(client) request , because i dont know how to convert User into something client understand

Quarkus is opionied framework, which looks up converter(Object to String) in the classpath.
Quarkus offers an extension(dependency) for converting Object to String(JSON).

pom.xml
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy-jsonb</artifactId>
    </dependency>


if you want to send xml as response

<dependency>
     <groupId>io.quarkus</groupId>
     <artifactId>quarkus-resteasy-jaxb</artifactId>
</dependency>

package com.cgi.rest.responses;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/responses")
public class ResponseResources {

    @GET
    @Path("/plain")
    public String sendPlainResponse() {
        return "Hello";
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    public User sendUserJSONResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Path("/user/xml")
    @Produces(MediaType.APPLICATION_XML)
    public User sendUserXmlResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }
    
    

}
..............................................................................................
Response:

Response class is abstract class contains two category of api

public abstract Object getEntity();
public abstract int getStatus();


Builder Class:

public static ResponseBuilder status(int status)
public static ResponseBuilder ok()
public static ResponseBuilder ok(Object entity)
public static ResponseBuilder created()
public static ResponseBuilder accepted()
public static ResponseBuilder noContent()
etc..


Builder is a design pattern through which you can chain methods and create instances on fly.

"hello".trim().toUppercase().toLowercase() - builder pattern


How to create Response Object?

javax.ws.rs.core.Response  class is abstract class, we cant create object directly, only possible via builder

Resonse.ok().build() -returns Response
 

package com.cgi.rest.responses;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/responses")
public class ResponseResources {

    @GET
    @Path("/plain")
    public String sendPlainResponse() {
        return "Hello";
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    public User sendUserJSONResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Path("/user/xml")
    @Produces(MediaType.APPLICATION_XML)
    public User sendUserXmlResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public Response sendResponse() {
        //Type of data to be sent
        return Response
                .ok("Hello Response")
                .header("myheader", "myheadervalue")
                .build();
    }


}
................................................................................................				Status Codes And RestFul Api Design
..............................................................................................
Status Code : 100 to 500

1XX Information Responses

100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2XX Success

200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used

3XX Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
306 Switch Proxy
307 Temporary Redirect
308 Permanent Redirect

4XX Client errors

400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 URI Too Long
415 Unsupported Media Type
416 Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
420 Method Failure
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
451 Unavailable For Legal Reasons

5XX Server errors
500 Internal Server error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 gateway Timeout
505 Http version not supported
506 Varient Also negotiate
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required


.............................................................................................
package com.cgi.rest.responses;

import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/responses")
public class ResponseResources {

    @GET
    @Path("/plain")
    public String sendPlainResponse() {
        return "Hello";
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    public User sendUserJSONResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Path("/user/xml")
    @Produces(MediaType.APPLICATION_XML)
    public User sendUserXmlResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public Response sendResponse() {
        //Type of data to be sent

        //OK -200 status - success
//        return Response
//                .ok("Hello Response")
//                .header("myheader", "myheadervalue")
//                .build();

//        return Response
//                .status(200)
//                .entity("Hello Response!!!")
//                .header("myheader", "myheadervalue")
//                .build();
//        return Response
//                .status(Response.Status.OK)
//                .entity("Hello Response!!!")
//                .header("myheader", "myheadervalue")
//                .build();
        return Response
                .status(Response.Status.OK)
                .entity("Hello Response!!!")
                .header("myheader", "myheadervalue")
                .build();
    }
    //Some Status code
    @POST
    public Response save(){
        return Response.status(201).entity("Saved").build();
    }


}
..............................................................................................
				  Negoation
..............................................................................................

What is Negoation?
 Agreeement between server and client what they can serve.

if client asks server that give me xml, means the server should able to give xml, if not it will give  response- not able to process your.

Content negotiation allows for an HTTP server to respond to different types of clients.

Many modern clients expect a JSON response, but there may be a need to format responses differently, maybe XML for older clients or a binary format for newer ones.


If the server is unable to provide the desired format, it will respond with a status code of 406, ‚ÄúNot Acceptable.‚Äù

Types of Negoation:

1.Content-Negotation
2.Language Negoation
3.Encoding Negoation


How to implement  Negotation?

Via Headers


Accept-*

Content Negotation
Accept: application/json,application/xml;

Language Negotation:
Accept-Language: fr

Encoding Negotation:
Accept-Encoding : gzip,deflate
..............................................................................................

Negotitation is just like a dialog between client and server.


At a high level, the conversation looks like this:

Client:
Hey Server!
I‚Äôd like to look at https://api.example.com/user/123.
I need your response in JSON.

	Server:
No Problem Client! Here is that response‚Ä¶‚Äã


Client:
Hey Server! I need https://api.example.com/user/123, preferably in JSON!
But, üò© I‚Äôll take XML if that‚Äôs all you have.
I also need the info in English or French.
Oh, please zip up the contents too.

GET /user/123 HTTP/1.1
Accept: application/json,application/xml;q=0.9
Accept-Encoding: gzip
Accept-Language: en,fr
Host: api.example.com
User-Agent: Client/2.0


Server:
Hey Client!
All I have is XML (sorry about that), the response is in English,
and I was able to zip it; here you go‚Ä¶‚Äã

                                        HTTP/1.1 200 OK
                                        Content-Type: application/xml
                                        Content-Encoding: gzip
                                        Content-Language: en

                                        <user id="123">
                                          ...
                                        </user>

..............................................................................................
Negotiation is bi directional.

Client ask with help of "Accept -*" Headers, Server will resonse with "Content-*" Headers

Content Negotation:

package com.cgi.rest.negotiation;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {

    //ContentNegation
    /**
     * GET  /negotiation/content Accept:application/json or Accept:application/xml
     */
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin", "admin");
        return Response.ok(user).build();
    }

}
.............................................................................................

How to send Data from the client to server (in the form of string(json,xml),binary?

How server negotiate with client to accept data?

Payload-body

package com.cgi.rest.negotiation;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {

      /**
     * POST negotation/create
     * body
     * content-type : Application/json / Application/xml
     */
    @POST
    @Path("/create")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response create(User user) {
        System.out.println(user);
        return Response.status(201).entity("Created").build();
    }


}
..............................................................................................						HTTP encoding
.............................................................................................

What is Content Encoding?

 if Server sends data, it can send directly

Compression Algorthim:

1.gzip
2.deflate

How to enable compression algorithm in quarkus?

application.properties
#quarkus.http.enable-compression=true
#quarkus.resteasy.gzip.enabled=true
#quarkus.resteasy.gzip.max-input=10M


If you want to compress everything then we recommended that you use the quarkus.http.enable-compression=true setting instead to globally enable compression support.


Response would be:

content-encoding:gzip
content-length:64
..............................................................................................

					Language Negotitation
..............................................................................................

if you ask the server that give me data in fr.

Accept-language : de /en

package com.cgi.rest.negotiation;

import org.jboss.resteasy.annotations.GZIP;

import javax.ws.rs.*;
import javax.ws.rs.core.*;
import java.util.List;
import java.util.Locale;

@Path("/negotiation")
public class ContentNegotiationResource {

    // GET /negotiation/lang 
    //Accept-language : en

    @Path("/lang")
    @GET
    public Response getLang(@Context Request request) {
        List<Variant> variants = Variant.VariantListBuilder
                .newInstance()
                .languages(Locale.ENGLISH, Locale.GERMAN)
                .build();
        Variant variant = request.selectVariant(variants);
        if (variant == null) {
            return Response.notAcceptable(variants).build();
        }
        String language = variant.getLanguageString();
        return Response.ok(language)
                .header(HttpHeaders.CONTENT_LANGUAGE, language)
                .build();
    }


}
..............................................................................................
					Exception Handling
..............................................................................................

Errors can be reported to a client either by creating and returning the appropriate
Response object or by throwing an exception.

Response Types:

1.SUCCESS Response
2.ERROR Response

How to handle / Convert ERRORS/Exceptions into HTTP Response Object?

 public Response getResponse(){

     return Response.ok().build();
 }

According to Application, Exception can be

1.System Exception :
  Exception thrown by jvm - NumberFormat,NullPointerException,ClassCastException.

2.Application Exception
   
  UserNotFoundException
  PasswordMissMatchException
  ...
public boolean validate(){

  if(passwordmatch){


  }
  else{ 
       throw new PasswordMismatchException("password does not match");
  } 
}
JAX-RS also provides the javax.ws.rs.WebApplicationException. 
This can be thrown by application code and automatically processed by JAX-RS without
having to write an explicit mapper.

WebApplicationException can be converted into Response Object.

Thrown exceptions are handledby the JAX-RS runtime if you have registered an exception mapper. 
Exception mappers can convert an exception to an HTTP response. 
If the thrown exception is not handledby a mapper, it is propagated and handled by the container (i.e., servlet) JAX-RS is running within.

How to write biz exception in jax rs?


package com.cgi.rest.exceptionhandling;

import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;

@Path("/myerrros")
public class ErrorResource {

    @GET
    @Path("{id}")
    public Response getResponse(@PathParam("id") String id) {
        if (id.equals("100")) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return Response.ok("Sucess" + id).build();
    }
}

When you run this code with "localhost:8080/myerrros/100"

Server will show exception like below?
rs.WebApplicationException: HTTP 404 Not Found
        at com.cgi.rest.exceptionhandling.ErrorResource.getResponse(ErrorResource.java:17)
        at com.cgi.rest.exceptionhandling.ErrorResource_Subclass.getResponse$$superforward1(ErrorResource_Subclass.zig:94)
        at com.cgi.rest.exceptionhandling.ErrorResource_Subclass$$function$$1.apply(ErrorResource_Subclass$$function$$1.zig:33)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:54)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:49)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(InvocationInterceptor_Bean.zig:521)
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:41)
        at io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)
        at com.cgi.rest.exceptionhandling.ErrorResource_Subclass.getResponse(ErrorResource_Subclass.zig:158)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)


how to convert this error into response and send to client?

package com.cgi.rest.exceptionhandling;

import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;

@Path("/myerrros")
public class ErrorResource {

    @GET
    @Path("{id}")
    public Response getResponse(@PathParam("id") String id) {
        if (id.equals("100")) {
            throw new WebApplicationException("Id " + id + "Not Found");
        }
        return Response.ok("Sucess" + id).build();
    }
}
.............................................................................................
			Context and Dependency Injection
					(CDI)
..........................................................................................

Object Composition: - HAS -A relationship

package com.cgi.hasa;

public class Product {
    private int productId;
    private String name;

    public Product() {
    }

    @Override
    public String toString() {
        return "Product{" +
                "productId=" + productId +
                ", name='" + name + '\'' +
                '}';
    }

    public Product(int productId, String name) {
        this.productId = productId;
        this.name = name;
    }

    public int getProductId() {
        return productId;
    }

    public void setProductId(int productId) {
        this.productId = productId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package com.cgi.hasa;

public class Order {
    private int orderId;
    private double orderValue;
    //has-a - dependancy
    private Product product;

    public Order() {
    }

    public Order(Product product) {
        this.product = product;
    }

    @Override
    public String toString() {
        return "Order{" +
                "orderId=" + orderId +
                ", orderValue=" + orderValue +
                ", product=" + product +
                '}';
    }

    public Order(int orderId, double orderValue, Product product) {
        this.orderId = orderId;
        this.orderValue = orderValue;
        this.product = product;
    }

    public int getOrderId() {
        return orderId;
    }

    public void setOrderId(int orderId) {
        this.orderId = orderId;
    }

    public double getOrderValue() {
        return orderValue;
    }

    public void setOrderValue(double orderValue) {
        this.orderValue = orderValue;
    }

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }
}

package com.cgi.hasa;

public class Main {
    public static void main(String[] args) {
        //Steps :
        //1.create objects
        //2.Link the objects
        Product product = new Product(1,"Book");
        Order order = new Order(1,1000,product);
        System.out.println(order);
    }
}

Here , what if there are more objects we need to create, and link them accordingly.

Product product = new Product(1,"Book");
Order order = new Order(1,1000,product);

Two complexity in enterprise computing:

1.creating objects
2.linking objects 

How to deal this complixity?

2000 ,Rod Johnson  who identified this problem - book - j2ee one on one design and developement.
   -how to reduce creating objects and links

He thought to write some automation software? he introduced a design pattern
 -IOC -  Inversion of Control.

What is IOC?

inversion - do opposit
of control -management

Developer has control for creating objects and link them -  we have to invert this task from developer
 
According to ioc, dont create object and link via coding. 

Who has to take care?
  -Automation software  ---- IOC Container.

Based on IOC Container idea,Rod who developed a framework in spring season "Spring Framework".

Spring Framwork abstracts away "creating objects and linking them from the developer".
............................................................................................. 

What is dependency Injection?
  
  Dependency -Object
  Injection - Injecting into Object

Objects are created by containers, available to programers for use.
..............................................................................................
How to get dependencies inside program? or How depedency Injection is happening?

-dependencies are injected via setter methods
-dependencies are injected via constructor methods
-dependencies are injected via "fiedls"  -J2EE CDI 
..............................................................................................
Core Concepts:

1.Bean :
  

What is Bean?
   
  Bean is terminallogy coined by SUN Micro System to name java object.

Object vs Bean?

 -Same but Bean has some special characteristics  which was proposed by SUN micro system via 
"Java Bean Spec"

It is java class, based Java Bean standards
 	-class should be public
 	-properties should be private
 	-set and get methods - Accessors and mutators
	-constructors

Why Bean Spec?
  - in order to standarize the java dev process- Coding Standards.

Many frameworks,containers,tools,compilers follow the bean standards only
eg: spring framework,ecplise,idea....

..............................................................................................

class Order {

}

class MyServlet extends HttpServlet{

}
MyServlet my=new MyServlet(); 
  -Extra features will be injected by container
    -lifecycles
    -thread managment
    -attching with http protocal

Order order=new Order()
..............................................................................................

Bean Types:

1.POJO Bean
   eg : order
2.Container Managed Bean

 - Container provides basic services
     - lifecycle callabacks,intercepters
     - creation,destroying
     - bean depdency lookup

Why Container Managed Bean?
   -Dev can focus only Applicaition logic...
............................................................................................
                                 Quarkus and Dependency Injection
............................................................................................

Quarkus uses MicroProfile CDI2.0 Spec, which intern refers 
  JSR 365: Contexts and Dependency Injection for JavaTM 2.0.

How Quarkus implements this spec?
 Quarkus ArC is a build-time oriented dependency injection based on CDI 2.0. 

.............................................................................................

                CDI is built on the concept of  "loose coupling,Strong Typing" 


                         Beans are loosely coupled but strongly typed


Apis in cdi:

1.javax.inject
2.javax.enterprise.inject - core di apis
3.javax.enterprise.context - scope and contextuaal apis
4.javax.enterprise.events -  publishing events and listening events-  container wide event driven programming
5.javax.enterprise.util
6.javax.interceptor

Common Annoations:

1.@Inject  
2.@Qualifer
3.LifeCycle of Bean
   @ApplicationScoped
   @SessionScoped
   @RequestScoped
   @SingleTon
 
4.@Observes - event listner
..............................................................................................

DI : Simple


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;

//bean
@ApplicationScoped
public class HelloService {

      public String sayHello(){
           return "Hello Service Bean";
      }
}



package com.cgi;

import com.cgi.di.HelloService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/hello")
public class HelloResource {

    @Inject
    HelloService helloService;

    @GET
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}

............................................................................................
			Bean Creation Exception-UnsatisfiedResolutionException


avax.enterprise.inject.UnsatisfiedResolutionException: Unsatisfied dependency for type com.cgi.di.HelloService and qualifiers [@Default]
	- java member: com.cgi.HelloResource#helloService
	- declared on CLASS bean [types=[java.lang.Object, com.cgi.HelloResource], qualifiers=[@Default, @Any], target=com.cgi.HelloResource]
	at io.quarkus.arc.processor.Beans.resolveInjectionPoint(Beans.java:492)
	at io.quarkus.arc.processor.BeanInfo.init(BeanInfo.java:463)


This exception is thrown when bean is not created -  
  due to 
    -no bean class  not present in the class path
    -you may forgot to annotate using lifecycle annotations -@ApplicationScoped...


eg:
public class HelloService {

      public String sayHello(){
           return "Hello Service Bean";
      }
}
 @Inject
 HelloService helloService;


.............................................................................................
                             Types of Injection in Quarkus  -Inection Points

1.Field Injection
2.Setter Injection
3.Constructor injection



1.Field Injection
1. @Inject
    HelloService helloService;


2.Setter Injection

    HelloService helloService;

    @Inject
    public void setHelloService(HelloService helloService) {
        this.helloService = helloService;
    }
3.Constructor injection

  @Inject
    public HelloResource(HelloService helloService) {
        this.helloService = helloService;
    }
 without @Inject annotation is also fine
   public HelloResource(HelloService helloService) {
        this.helloService = helloService;
    }
..............................................................................................
			   Service has its dependencies
..............................................................................................


 Resource-----Service-----Utility Bean
 Resource -----Service----Repository


interface:
package com.cgi.di;

public interface NumberGenerator {
    //Generate ISBN Number
    String generateNumber();
}

Implementation
package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import java.util.Random;

@ApplicationScoped
public class IsbnGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "15-87654" + Math.abs(new Random().nextInt());
    }
}


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

@ApplicationScoped
public class BookService {

    //Inject interface
    @Inject
    NumberGenerator numberGenerator;

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}

package com.cgi;

import com.cgi.di.BookService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/books")
public class BookResource {

    @Inject
    BookService bookService;

    @GET
    public Response createBook(){
        return Response.ok(bookService.createBook()).build();
    }
}
.................................XXXXXXXXXXXXXX...............................................
                               Interface and its multiple implementation
..............................................................................................

public interface myInterface{
    String mymethod();

}
public class Myclass1 implements MyInterface {
   public String mymethod(){
           return "Mymethod-1";
   }
}                         
public class Myclass2 implements MyInterface {
   public String mymethod(){
           return "Mymethod-2";
   }
}                         

@Inject
MyInterface myinter;

myinter.mymethod();


avax.enterprise.inject.AmbiguousResolutionException: Ambiguous dependencies for type com.cgi.di.NumberGenerator and qualifiers [@Default]
	- java member: com.cgi.di.BookService#numberGenerator
	- declared on CLASS bean [types=[java.lang.Object, com.cgi.di.BookService], qualifiers=[@Default, @Any], target=com.cgi.di.BookService]
	- available beans:

Here error because , container cant understand what bean you want to inject.

How to solve this problem?

Qualifiers
   Injecting Qualified beans which you want bean implemenation you want.

Is there any default qualifier?

Yes

@Default

if there is only one implementation, injection works using @Default qualifier.

if there is more than one implementation , container will throw AmbiguousResolutionException

How to write Qualifier?

We have to write custom  Qualifer annotation


Steps:

1.For isbn generator class
package com.cgi.di;

import javax.inject.Qualifier;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Qualifier
@Retention(RUNTIME)
@Target({FIELD,TYPE,METHOD})
public @interface ThirteenDigitQualifier {
}

2.For issbn geneartor

package com.cgi.di;

import javax.inject.Qualifier;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Qualifier
@Retention(RUNTIME)
@Target({FIELD,TYPE,METHOD})
public @interface EightDigitQualifier {
}


3.Annotate The Implementation classes

package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import java.util.Random;

@ThirteenDigitQualifier
@ApplicationScoped
public class IsbnGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "15-87654" + Math.abs(new Random().nextInt());
    }
}

package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import java.util.Random;

@EightDigitQualifier
@ApplicationScoped
public class ISSNGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "8 -" + Math.abs(new Random().nextInt());
    }
}

package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Default;
import javax.inject.Inject;

@ApplicationScoped
public class BookService {

    //Inject - default
//    @Inject @Default
//    NumberGenerator numberGenerator;

//    @Inject @EightDigitQualifier
//    NumberGenerator numberGenerator;

    //Without Inject Annotation itself
    @EightDigitQualifier
    NumberGenerator numberGenerator;
    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}

............................................................................................
				 Injecting Alternate Beans
............................................................................................

Qualifiers help us to select multiple implementations of an interface development time
But sometimes you want to inject an implemenation depending on  a particular deployment scenario.

For for test environment i wanto use mockgenertor api.


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Alternative;

@Alternative
@ApplicationScoped
public class MockGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "MOCK ";
    }
}

Note:
By default alternatives are disable and need to be enabled to make them available for instantiation and injecton


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Alternative;
import javax.enterprise.inject.Default;

@Alternative
@ApplicationScoped
@Default
public class MockGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "MOCK ";
    }
}

This is alternate bean for "Default Injection" meaning that only one implemenation.

...........................................................................................
				Bean Scopes
...........................................................................................



1.@ApplicationScoped
     Bean is created and kept entire life of application
     Only one time is created - singleton
     
2.Request,Session
   -A bean can be bound to single request cycle-  mostly used in old dynamic webapps
    eg: Spring MVC,Struts
   -Session scope 
     single user multiple requests.

3.@SingleTon
      -only one instance per container

Applicationscope vs singleton

-singleton beans are eagerly created
--application beans are lazy - uses a factory -client proxy
-singleton is some what performance good.Applicationscope uses delegation pattern to delegate objects to proxy classes
-Singletons cant be used to create Mock using QuarksMock under test
..............................................................................................
			Types of beans with respect to data injection
..............................................................................................

1.class beans
  
...variables and methods itself can be treated as dependency
2.Producer methods
3.Producer fields
.....................
4.Syntenetics beans


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import java.util.ArrayList;
import java.util.List;

@ApplicationScoped
public class Producers {

    //instance variable
    @Produces
    double price = 1000.90;

    @Produces
    List<String> topics(){
        List<String> topics = new ArrayList<>();
        topics.add("cdi");
        topics.add("configuration");
        topics.add("RestEasy");
        return topics;
    }


}




package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.util.List;

@ApplicationScoped
public class BookService {

    //Inject - default
//    @Inject @Default
//    NumberGenerator numberGenerator;

//    @Inject @EightDigitQualifier
//    NumberGenerator numberGenerator;

    //Without Inject Annotation itself
    @EightDigitQualifier
    NumberGenerator numberGenerator;

    @Inject
    double price;

    @Inject
    List<String> topics;

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }

    public double calculatePrice() {
        return price;
    }

    public List<String> getTopics() {
        return topics;
    }
}
..............................................................................................
					Life Cycle Hooks
..............................................................................................

init and destory

package com.cgi.di;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.util.List;

@ApplicationScoped
public class BookService {

    //Inject - default
//    @Inject @Default
//    NumberGenerator numberGenerator;

//    @Inject @EightDigitQualifier
//    NumberGenerator numberGenerator;

    //Without Inject Annotation itself
    @EightDigitQualifier
    NumberGenerator numberGenerator;

    @Inject
    double price;

    @Inject
    List<String> topics;

    @PostConstruct
    public void init() {
        System.out.println("Init is called");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Destroy is called");
    }

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }

    public double calculatePrice() {
        return price;
    }

    public List<String> getTopics() {
        return topics;
    }
}
..............................................................................................
			        Interceptors :Cross Cutting Concerns
.............................................................................................

What is concern?
   concern means features like transaction,security,logging

Cross cutting means, removing these concerns from the application logic.

How to cross cutting concerns?
 There is spec all "java interceptors" 


How to define intercetor

@Interceptor
public class MyInterceptor {

 //logic : concern

 public Object loggerInvocation(InvocationContext ctx) {
     //log here
     Object res= ctx.proceed();
    //log here

    return res
 }


}

Implemenation:
package com.cgi.di;

import com.cgi.di.interceptors.LogEvent;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.util.List;

@ApplicationScoped
public class BookService {

    //Inject - default
//    @Inject @Default
//    NumberGenerator numberGenerator;

//    @Inject @EightDigitQualifier
//    NumberGenerator numberGenerator;

    //Without Inject Annotation itself
    @EightDigitQualifier
    NumberGenerator numberGenerator;

    @Inject
    double price;

    @Inject
    List<String> topics;

    @PostConstruct
    public void init() {
        System.out.println("Init is called");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Destroy is called");
    }

    //biz method
    @LogEvent
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }

    public double calculatePrice() {
        return price;
    }

    public List<String> getTopics() {
        return topics;
    }
}

..............................................................................................
                           Private keyword on Dependency field

Quarkus and its native image generation performs better
CDI work without private members. Dependency injection requires a
lot of Reflection API usage, which is very expensive. In the interest of
generating better-performing native images, don‚Äôt use the private
modifier for fields. Stick with package-level access for class-level
variables.
......................................
Quarkus-Only Enhancements to CDI Quarkus enriches its implementation of CDI in ArC, by adding the following features, among others.

..............................................................................................
				Micro services Pattern implementation
..............................................................................................

                                 Distributed Configuration

How to configure The application?

with in the application scope
application.properties
application.yaml

outside application scope
distributed config store
-consul
-appache zoo keeper

Quarkus uses microprofile configuration spec, Which implemented in SmallRye Config.

By default, Quarkus reads configuration properties from several sources.


Config sources

1.Property file -  application.properties
2.Environment variable - export myenv=value
3.system variable
4. .env file
5.external systems- config servers
 -kubernets
 -consl
  
In MicroProfile Config, a ConfigSource represents a Map<String, String> of property names to
values, and a Config represents a sequence of ConfigSources, ordered by priority.

The priority of a ConfigSource is given by an ordinal (represented by an int), with a higher value indicating a higher priority.

For a given property name, the ConfigSources are searched in order until a value is found.

MicroProfile Config mandates the presence of the following ConfigSources:
1. a ConfigSource based on System.getProperties() (ordinal = 400)
2. a ConfigSource based on System.getenv() (ordinal = 300)
3. a ConfigSource for each META-INF/microprofile-config.properties file on the ClassPath, separately
configurable via a config_ordinal property inside each file (default ordinal = 100)

1. Config Sources
By default, Quarkus reads configuration properties from multiple sources (by descending ordinal):

(400) System properties

(300) Environment variables

(295) .env file in the current working directory

(260) Quarkus Application configuration file in $PWD/config/application.properties

(250) Quarkus Application configuration file application.properties in classpath

(100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath
.............................................................................................

How to read Configuration from application.properties ?

Properties are key-value pair structure.

key is based on dns naming standard
com.cgi.myapp.greeter.message=Hello

or 
greeter.message


How to read property?

@Inject @ConfigProperty(name="greeter.message")
String message;


Eg:

application.properties
greeter.message=Hello,I am From Property File

package org.acme;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

//    @Inject @ConfigProperty(name="greeter.message")
    @ConfigProperty(name="greeter.message")
    String message;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return message;

    }
} 
..........................................................................................

What if the property is not supplied? - no property is present?

-You will get 

java.util.NoSuchElementException: SRCFG00014: The config property greeter.message is required but it could not be found in any config source
	at io.smallrye.config.SmallRyeConfig.convertValue(SmallRyeConfig.java:307)
	at io.smallrye.config.inject.ConfigProducerUtil.getValue(ConfigProducerUtil.java:81)
	at io.quarkus.arc.runtime.ConfigRecorder.validateConfigProperties(ConfigRe

Solution : 

default Value

What if i have more propeties?

greeter.message=Hello,From Property
greeter.name=Subramanian
greeter.date=today

package org.acme;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    //    @Inject @ConfigProperty(name="greeter.message")
    @ConfigProperty(name = "greeter.message", defaultValue = "Hello RestEasy!")
    String message;
    @ConfigProperty(name = "greeter.name", defaultValue = "foo")
    String name;
    @ConfigProperty(name = "greeter.date", defaultValue = "some value")
    String date;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return name + " " + message + " " + date;

    }
}
............................................................................................

Programmetic way of reading properties.

ConfigProvider.getConfig().getValue("propertyName",String.class)

application.property
myuser.name=Subramanian

  @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/greet")
    public String greet() {
        String userName = ConfigProvider.getConfig().getValue("myuser.name", String.class);
        return userName;

    }
.............................................................................................

System Properties:

 System properties are supplied through -D flag during startup.

Dev Mode:

 mvn  compile quarkus:dev  -Dgreeter.message=Hello,FromSystem
 
Production Mode
 -JVM- Runnar Jar
    java -Dgreeter.message=Hello,FromSystem -jar target/quarkus-app/quarkus-run.jar

-Native Mode
    export GREETER_MESSAGE=Hello,FromSystem;   ./target/myapp-runner 

eg:
>mvn compile quarkus:dev -Dgreeter.message=Hello,FromSystem


package org.acme;

import org.eclipse.microprofile.config.ConfigProvider;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    //    @Inject @ConfigProperty(name="greeter.message")
    @ConfigProperty(name = "greeter.message", defaultValue = "Hello RestEasy!")
    String message;
    @ConfigProperty(name = "greeter.name", defaultValue = "foo")
    String name;
    @ConfigProperty(name = "greeter.date", defaultValue = "some value")
    String date;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return name + " " + message + " " + date;

    }

    //how to read property via configProvider
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/greet")
    public String greet() {
        String userName = ConfigProvider.getConfig().getValue("myuser.name", String.class);
        return userName;

    }


}

Output:

http://localhost:8080/hello
Subramanian Hello,FromSystem today
..............................................................................................
			How to read Properties from Envinonment Variables
..............................................................................................

In Unix/Linux,Mac, How to set env variables

export VariableName=value

In windows

SET VariableName=value

...........................................................................................

Use case : Property file config and Env Variable


steps:

1.mvn clen
2.mvn package -DskipTests=true
3.SET GREETER_MESSAGE=Hello,FromEnv
4.java -jar target/quarkus-app/quarkus-run.jar
5.http://localhost:8080/hello
output:
Subramanian HelloFromENv today

What if i have 
.greeter.message property in application.property file
and supply via Env variable
and supply via system property 

Which property value will be displayed?
  -system property.
..............................................................................................
			     	.env file

env files isloate all env variables and group into single source of the trugh

.env file in the current working directory

QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 
The name QUARKUS_DATASOURCE_PASSWORD the same conversion rules used for Environment variables.
For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.


steps:

1.create .env file inside project root dir

config-app
src
target
.env

2.Add config information inside .env file
 -Name of the Property should be UPPERCASE_UPPERCASE=value like Env variable

.env
GREETER_MESSAGE=Hello,FromENVFILE


3.build app and run test

http://localhost:8080/hello
Subramanian Hello,FromENVFILE today
..............................................................................................
		      Can We have multiple application.properties 
............................................................................................

Yes , we can multiple application.properties files


Locations:
 
1.
src
 |
 main
  |
  resources
     application.proprties

2.App-name - config-app
   
  config
	|
     application.properties

 src
 |
 main
  |
  resources
     application.proprties

You have to run in production mode , for the first file options

-mvn clean
-mvn package
-java -jar target/quarkus-app/quarkus-run.jar
.............................................................................................
		How to externalize the property injections into Separate Program
.............................................................................................

Use case:

import javax.ws.rs.Path;

@Path("/customer")
public class CustomerResource {

    @ConfigProperty(name = "firstName")
    String firstName;
    String city;
    String state;
    String lastName;

}
Grouping properties with @ConfigurationProperties

package org.acme;


import io.quarkus.arc.config.ConfigProperties;
import org.eclipse.microprofile.config.inject.ConfigProperty;
//import org.eclipse.microprofile.config.inject.ConfigProperty;

@ConfigProperties(prefix = "cust")
public class CustomerConfiguration {
    @ConfigProperty(name = "name", defaultValue = "default Customer Name")
    public String name;
}

application.properties
cust.name=foo


package org.acme;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/customer")
public class CustomerResource {

    @Inject
    CustomerConfiguration custConfig;

    @GET
    public String customerInfo() {
        //  return custConfig.firstName;
        return custConfig.name + "Hello";
    }
}
.............................................................................................

@ConfigProperties has been deprecated: dont use in latest Quarkus implementations:
...................................................................................

Use @ConfigMapping annotation on interface level

application.properties
cust.name=Subramanian

@ConfigMapping(prefix="cust")
public interface CustomerConfiguration {

   //name
    String name();

}
package org.acme;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/customer")
public class CustomerResource {

    @Inject
    CustomerConfiguration custConfig;
    @GET
    public String customerInfo() {
        return custConfig.name();
    }
}

Res:
http://localhost:8080/customer

Subramanian
.............................................................................................
How to configure default values in the @ConfigMapping annotation

@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    String name();
}

There is type provided by java " java.util.Optional<T>":

Optional class helps to convert null into usefull defaults.

Java has the very problem is NullPointerException.


 eg:
    Customer customer= service.findById(10)
    log.info(customer.getCity());

   The result would be
   -Customer
       or
   -null
if there is no customer which throws null pointer exception?

How to solve this problem?

Way - 1
  if(customer!=null){ 
     log.info(customer.getCity());
  }else{

     log.info("customer not found")
  }

Way -2

     String city = service.findById(10).orElse("Default City")

..........................................................................................
application.properties
#cust.name=Subramanian

@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    Optional<String> name();
}

@GET
 public String customerInfo() {
        return custConfig.name().orElse("default Name");
   }
}
.............................................................................................
				   Nested properties

application.properties
cust.address.city=coimbatore

@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    Optional<String> name();
    Address address();
    //inner type
    interface Address {
        Optional<String> city();
    }
}
    public String customerInfo() {
        String city = custConfig.address().city().orElse("coimbatore");
        return custConfig.name().orElse("default Name") + " " + city;
    }
}
.............................................................................................
Programmetic access

SmallRyeConfig config = ConfigProvider.getConfig.unWrap(SmallRyeConfig.class);
CustomerConfiguration cust=config.getConfigMapping(CustomerConfiguration.class);
............................................................................................
What if application.properties key name is different from programmetic name

application.properties
cust.firstName=Subramanian


@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    @WithName("firstName")
    Optional<String> name();
    Address address();
    //inner type
    interface Address {
        Optional<String> city();
    }
}
..............................................................................................
					Profiles
.............................................................................................

Profiles:
  The environment where the application is running

1.dev
2.test
3.prod

Profile in the the property name:

%{profile-name}.config.name

Profile Names in Qurakus:

dev - development
prod - production profile
test -  test profile

profile specification configuration:

application.properties

%dev.message.greet=messagefrom dev
%prod.message.greet=messagefromprod

.env file
_{PROFILE}_CONFIG_KEY=VALUE

_DEV_MESSAGE_GREET=VALUE

eg:

1.application.properties
%dev.greeter.message=Hello,From Property Development
%prod.greeter.message=Hello,From Property Production


profile aware files

application-profile.properties

application-dev.properties
application-prod.properties

eg:

Steps:
1.Add application-prod.properties inside src/main/resources folder
greeter.message=Hello,From Property Production&&&

2.run in dev mode and test it

3.run in production mode and test it.
..............................................................................................
						YAML
..............................................................................................
YAML Getting started:
https://www.redhat.com/en/topics/automation/what-is-yaml


How to enable yaml configurations?

mvn quarkus:add-extension -Dextensions="io.quarkus:quarkus-config-yaml

<dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-config-yaml</artifactId>
</dependency>

old properties- application.properties
%dev.greeter.message=Hello,From Property Development!!!
#%prod.greeter.message=Hello,From Property Production
greeter.name=Subramanian
greeter.date=today
myuser.name=Subramanian
cust.firstName=Subramanian
cust.address.city=Chennai

application.yaml

"%prod":
  greeter:
    message: The Message From Production

"%dev":
  greeter:
    message: The Message From Development
"%test":
  greeter:
    message: The message From Test
greeter:
  name: Subramanian
  message: Hello,From YAML
  date: Today
myuser:
  name: Myuser
cust:
  firstName: Subramanian
  address:
    city: Delhi
..............................................................................................
				Quarkus built in properties


Quarkus properties begin with "qurakus.modulename.property"


"%prod":
  greeter:
    message: The Message From Production
  quarkus:
    http:
      port: 3001

"%dev":
  greeter:
    message: The Message From Development
    # Update existing quarkus related properties
    quarkus:
      http:
        port: 3000

"%test":
  greeter:
    message: The message From Test
greeter:
  name: Subramanian
  message: Hello,From YAML
  date: Today
myuser:
  name: Myuser
cust:
  firstName: Subramanian
  address:
    city: Delhi

Yaml files:

application.yaml
application-prod.yaml
config/application.yaml
..............................................................................................
				Centeralized Configuration
..............................................................................................

What if i want to  keep the general  configuration data across the microservices?

-Centeralized config store.

There are lot of configuration server applications are there.

1.Hashicorp vault
2.Consul
3.Spring cloud
...........................................................................................
				  Consul: Reading Properties
.............................................................................................

Requirement:

1.Your application
2.Consul Server - You need to run consul server separtly.


Project Setup:

mvn io.quarkus:quarkus-maven-plugin:2.1.3.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=config-consuleapp \
    -DclassName="org.acme.GreetingResource" \
    -Dpath="/greeting" \
    -Dextensions="consul-config"
cd config-consuleapp

    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-consul-config</artifactId>
    </dependency>

Lets start coding:

1.Have simple config property, return the value

package org.acme;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @ConfigProperty(name = "greeting.message", defaultValue = "Hello RESTEasy")
    String message;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return message;
    }
}

Getting Property from consul server:

Steps:

1.start consul server.

-Via Docker
open cmd prompt and run this

$ docker run --rm --name consul -p 8500:8500 -p 8501:8501 consul:1.7 agent -dev -ui -client=0.0.0.0 -bind=0.0.0.0 --https-port=8501

2.browse consul page.
  http://localhost:8500/ui/dc1/kv/create
As of now , dont enter any thing.

3.You have to connect application with consul server, for that you need to configure via application.properties or application.yaml


application.properties

#greeting.message=Hello,application.properties
#application name: We have to use this name as the application name that was
# configured when standing up the config server
quarkus.application.name=consul-app
#enable retrieval of configuration from the consule -this is by default is disabled
quarkus.consul-config.enabled=true
#Key in Consul's KV store that the Quarkus application will read and try to extract properties from
quarkus.consul-config.properties-value-keys=config/${quarkus.application.name}
.............................................................................................
                            Advanced Consul Configuration
...........................................................................................

quarkus.consul-config.enabled

If set to true, the application will attempt to look up the configuration from Consul

boolean

false

quarkus.consul-config.agent.host-port

Consul agent host

host:port

localhost:8500

quarkus.consul-config.agent.use-https

Whether or not to use HTTPS when communicating with the agent

boolean

false

quarkus.consul-config.agent.token

Consul token to be provided when authentication is enabled

string

quarkus.consul-config.agent.trust-store

TrustStore to be used containing the SSL certificate used by Consul agent Can be either a classpath resource or a file system path

Show more
path

quarkus.consul-config.agent.trust-store-password

Password of TrustStore to be used containing the SSL certificate used by Consul agent

string

quarkus.consul-config.agent.key-store

KeyStore to be used containing the SSL certificate for authentication with Consul agent Can be either a classpath resource or a file system path

Show more
path

quarkus.consul-config.agent.key-store-password

Password of KeyStore to be used containing the SSL certificate for authentication with Consul agent

string

quarkus.consul-config.agent.key-password

Password to recover key from KeyStore for SSL client authentication with Consul agent If no value is provided, the key-store-password will be used

Show more
string

quarkus.consul-config.agent.trust-certs

When using HTTPS and no keyStore has been specified, whether or not to trust all certificates

boolean

false

quarkus.consul-config.agent.connection-timeout

The amount of time to wait when initially establishing a connection before giving up and timing out. Specify 0 to wait indefinitely.

Show more
Duration 

10S

quarkus.consul-config.agent.read-timeout

The amount of time to wait for a read on a socket before an exception is thrown. Specify 0 to wait indefinitely.

Duration 

60S

quarkus.consul-config.prefix

Common prefix that all keys share when looking up the keys from Consul. The prefix is not included in the keys of the user configuration

Show more
string

quarkus.consul-config.raw-value-keys

Keys whose value is a raw string. When this is used, the keys that end up in the user configuration are the keys specified her with '/' replaced by '.'

Show more
list of string

quarkus.consul-config.properties-value-keys

Keys whose value represents a properties file. When this is used, the keys that end up in the user configuration are the keys of the properties file, not these keys

Show more
list of string

quarkus.consul-config.fail-on-missing-key

If set to true, the application will not start if any of the configured config sources cannot be located

.............................................................................................
					
Other Implementations:
-if you have spring cloud config server.
.............................................................................................
				   Data Sources
.............................................................................................

Data sources;

1.sql
2.nosql

How to connect with sql Data Sources?

1.JDBC
  Core 
2.DataSource Object is abstraction on JDBC

Quarkus Datasouces:

1.Agroal Non Reactive Datasource driver
   Agroal library allows the definition of java.sql.DataSource with connection pooling
2.Vert.x Reactive Drivers

How to setup datasources?

1.configure single datasource or multiple datasource
2.how to obtain datasource object in code
3.how to work with datasources


Zero Config Setup (Dev Services)
.................................

1.Postgresql (container)
2.MySQL (container)
3.MariaDB (container)
4.H2 (in-process)
5.Apache Derby (in-process)
6.DB2 (container) (requires license acceptance)
7.MSSQL (container) (requires license acceptance)

container- separate running outside app
in-process - as part of application.


Datasource configuration in application.properties/yaml

Add the agroal extension plus one of jdbc-db2, jdbc-derby, jdbc-h2, jdbc-mariadb, jdbc-mssql, jdbc-mysql, jdbc-oracle or jdbc-postgresql.

Then configure your datasource:

quarkus.datasource.db-kind=postgresql 
quarkus.datasource.username=<your username>
quarkus.datasource.password=<your password>

quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16


Default datasource
quarkus.datasource.db-kind=h2 

db-kind: short name to refer database configuration information

DAtabase kinds
We currently include these built-in database kinds:

DB2: db2
Derby: derby
H2: h2
MariaDB: mariadb
Microsoft SQL Server: mssql
MySQL: mysql
Oracle: oracle
PostgreSQL: postgresql, pgsql or pg

..
Drivers:

DB2 - jdbc-db2

Derby - jdbc-derby

H2 - jdbc-h2

MariaDB - jdbc-mariadb

Microsoft SQL Server - jdbc-mssql

MySQL - jdbc-mysql

Oracle - jdbc-oracle

PostgreSQL - jdbc-postgresql
.............................................................................................

How to use datasource inside code?

DI:

Consuming the datasource
@Inject
AgroalDataSource defaultDataSource;
............................................................................................
				Micro Service Data Management Pattern
............................................................................................

How quarkus supports Microservice datata management pattern?

1.Database per service
2.Shared database

1.Database per service.

  We need to configure multiple datasources.

Quarkus supports multi datasource configuration

default Database:

quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:default
quarkus.datasource.jdbc.max-size=13

I have User service, which needs user db.

Syntax:

quarkus.datasource.serviceName.db-kind

quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:tcp://localhost/mem:users
quarkus.datasource.users.jdbc.max-size=11

quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:tcp://localhost/mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12



DI
@Inject
AgroalDataSource defaultDataSource;

@Inject
@DataSource("users")
AgroalDataSource usersDataSource;

@Inject
@DataSource("inventory")
AgroalDataSource inventoryDataSource;

public class UserService {

@Inject
@DataSource("users")
AgroalDataSource usersDataSource;
}
.............................................................................................

Eg:

Plain JDBC Code using Datasource

Set up Project :

     <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-jdbc-h2</artifactId>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-agroal</artifactId>
    </dependency>


package org.acme;

import io.agroal.api.AgroalDataSource;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

@Path("/hello")
public class GreetingResource {


    @Inject
    AgroalDataSource defaultDataSource;

    @GET
    public Response getConnectionStatus() {
        try {
            Connection conn = defaultDataSource.getConnection();
            Statement stmt = conn.createStatement();
            stmt.executeUpdate("CREATE TABLE TABLE1(id INT NOT NULL,  title VARCHAR(50))");
            stmt.executeUpdate("INSERT INTO TABLE1 " + "VALUES (100, 'Subramanian')");
            ResultSet rs = stmt.executeQuery("select * from table1");
            while (rs.next()) {
                System.out.println(rs.getInt(1) + "  " + rs.getString(2));
            }
            stmt.close();
            conn.close();
        } catch (Exception es) {
            System.out.println("Database error" + es.getMessage());
        }
        return Response.ok().build();
    }

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello RESTEasy";
    }
}
..............................................................................................
			        Quarkus-ORM
			   JPA,Hibernate,Panache
..............................................................................................


What is JPA?
  JPA is JEE Standard to build object relational mapping technologies.

History of ORM:

-ORM Technology introduced in EJB 
   Entity Bean
Because of drawback of Entity Beans,The developer who created a framework based ejb entity bean called "Hibernate"


How Hibernate works?

Object ----is mapped in xml-->loaded into hibernateEngine---Will start all persistency.


Object is mapped via annotations--loaded into hibernateEngine---Will start persistency

				   App Java Apps
					|
				     Objects
					|
				    xml or Annotation
					|
				   Hibernate Engine(Will translate SQL QUERES)
					 |
				     DataSource
				          |
				    JDBC Driver


Once ORM Technologies started becoming popular JCP, started standarzing ORM, who relased spec
"JPA"

What is JPA?
  STANDARD can be used by developer who can use any persistency implementation-Hibernate,X,Y..


				    ORM APPS
					|
				       JPA 
				-----------------------
			        |        |     |      
			   Hibernate  IBatis  Toplink
..............................................................................................
				Quarkus and JPA

Quarkus provides two abstraction on JAP

1.JPA - Hibernate
					APP
					 |
					JPA
					 |
				      Hibernate

2.JPA - Panche - Hibernate

					 APP
					  |
					 JPA
					  |
					PANCHE
					  |
				       HIBERNATE


............................................................................................

1.JPA - Hibernate


JPA Entity:

What is Entity?
 Object,which lives in only main memory
 Object which lives beyond main memory- persistable/seriazliable  -Enity

@Entity
@Table( name = "EVENTS" )
public class Event {
    ...
}

table:
 columns
   each column will have type,rules
identity column
domain columns
every table must have id.

@Id
@GeneratedValue(generator="increment")
@GenericGenerator(name="increment", strategy = "increment")
public Long getId() {
    return id;
}

column mapping :

class fields are mapped to table columns and its type is mapped to column datatype.
if i want to overiride column name

public String getTitle() {
    return title;
}

@Temporal(TemporalType.TIMESTAMP)
@Column(name = "EVENT_DATE")
public Date getDate() {
    return date;
}

Basic rules for entity as per jpa spec

1.class must be public
2.fields must be declared private
3.setter and getters
4.may have additional constructors
.............................................................................................
				Manipulating JPA Entity
............................................................................................

CURD Operations:
.................

JPA and Hibernate objective is not write any sql statements.who provides api to send data and read data from the database

CREATE:/SAVE - Insert Query

EntityManager entityManager = sessionFactory.createEntityManager();
entityManager.getTransaction().begin();
entityManager.persist( new Event( "Our very first event!", new Date() ) );
entityManager.persist( new Event( "A follow up event", new Date() ) );
entityManager.getTransaction().commit();
entityManager.close();

LIST: Select Query

entityManager = sessionFactory.createEntityManager();
entityManager.getTransaction().begin();
List<Event> result = entityManager.findAll()
for ( Event event : result ) {
	System.out.println( "Event (" + event.getDate() + ") : " + event.getTitle() );
}
entityManager.getTransaction().commit();
entityManager.close();
.............................................................................................

Project Setup:

pom.xml
    <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-jdbc-h2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-orm</artifactId>
        </dependency>

   <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-resteasy-jackson</artifactId>
        </dependency>


application.properties


Enity class
package org.acme.enity;

import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name = "events")
public class Event {
    @Id
    @SequenceGenerator(name = "eventseq", sequenceName = "event_id_seq", allocationSize = 1, initialValue = 1)
    @GeneratedValue(generator = "eventseq")
    private int eventId;
    @Column(name = "event_title")
    private String title;
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "event_date")
    private Date eventDate;

    public Event() {
    }

    public Event(String title, Date eventDate) {
        this.title = title;
        this.eventDate = eventDate;
    }

    public int getEventId() {
        return eventId;
    }

    public void setEventId(int eventId) {
        this.eventId = eventId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Date getEventDate() {
        return eventDate;
    }

    public void setEventDate(Date eventDate) {
        this.eventDate = eventDate;
    }
}

Service:
package org.acme.service;

import org.acme.enity.Event;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.transaction.Transactional;
import java.util.Date;
import java.util.List;

@ApplicationScoped
public class EventService {

    @Inject
    EntityManager entityManager;

    public List<Event> findAll() {
        //JPQL - Java Persistency Query Language
        return entityManager.createQuery("SELECT e FROM Event e", Event.class).getResultList();
    }

    @Transactional
    public void createEvent() {
        Event event = new Event("Our very first event!", new Date());
        //entityManager.getTransaction().begin();
        entityManager.persist(event);
        //entityManager.getTransaction().commit();
    }
}

package org.acme;

import org.acme.service.EventService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/events")
public class EventResource {

    @Inject
    EventService eventService;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response listEvents() {
        return Response.ok(eventService.findAll()).build();
    }

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Response createEvent() {
        eventService.createEvent();
        return Response.status(201).entity("Event Created").build();
    }
}

Testing

POST /localhost:8080/events

GET /localhost:8080/events
............................................................................................
				JPA-Hibernate-Panche
...........................................................................................

Panche:
 Panche is just wrapper on top of JPA-Hibernate.


Panche Entities:

@Entity
public class Event extends PancheEntity {

}

-It becomes eventity and also apis to manipulate Entity

Panche PRogramming can be written using two design patterns

1.Active Record pattern
2.DAO Patter or Repository Pattern

Panche Entity Rules

1.variables are declared using public keyword with no setters and getters

2.id property , identifier logic not necessary by default.

3.State and behaviour in the same class
   public String name; -state
   findByName()-behaviour   
4.Simplied query operations
    using JPQL but simplified syntax.

@Entity
public class Event extends PancheEntity {

}

if you want to customize id generation 
@Entity
public class Event extends PancheEntityBase {

}

1.Active Record pattern:
  You can use entity instance directly into Service/Resources

 Event.findAll()
 Event.findById(id)
 Event.persist()
 Event.delete()
 Event.update()

2.Repository Pattern/DAO pattern

-Create Entity separatly : follow all jpa entity rules

@Enity
public class Event {
  private int id;
  private String title
  //setters and getters
}
-Create Repository class
 @ApplicationScoped
 public class EventRepository implements PanacheRepository<Event> {
  
 }

-Dependency Injection into Service or Resource

@ApplicationScoped
public class EventService{

    @Inject
    EventRepository eventRepo

}
...............................................................................................

Eg:

package org.acme.entity;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.util.Date;

@Entity
@Table(name = "events")
public class Event extends PanacheEntity {
    @Column(name = "event_title")
    public String title;
    @Column(name = "event_date")
    public Date eventDate;

    //custom api
    public static Event findByTitle(String title) {
        return find("title", title).firstResult();
    }
}
............................................................................................
package org.acme;

import org.acme.entity.Event;
import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.transaction.Transactional;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;
import java.net.URI;
import java.util.Date;
import java.util.List;

@Path("/events")
@Produces(MediaType.APPLICATION_JSON)
public class EventResource {

    @GET
    public List<Event> list() {
        return Event.listAll();
    }

    @GET
    @Path("/{id}")
    public Event get(@PathParam("id") Long id) {
        Event event = Event.findById(id);
        if (event == null) {
            throw new WebApplicationException("Event with Id of " + id + " Not Found");
        }
        return event;
    }

    @GET
    @Path("/search/{name}")
    public Event search(@PathParam("name") String name) {
        Event event = Event.findByTitle(name);
        if (event == null) {
            throw new WebApplicationException("Event with Name of " + name + " Not Found");
        }
        return event;
    }

    @GET
    @Path("/count")
    public Response countEvents(@PathParam("name") String name) {
        return Response.ok(Event.count()).build();
    }

    @DELETE
    @Path("/{id}")
    @Transactional
    public void removeEvent(@PathParam("id") Long id) {
        Event event = Event.findById(id);
        if (event == null) {
            throw new WebApplicationException("Event with Id of " + id + " Not Found");
        }
        event.delete();
    }

    @PUT
    @Path("/{id}")
    @Transactional
    public Response updateEvent(@PathParam("id") Long id, Event event) {
        Event foundEvent = Event.findById(id);
        if (foundEvent == null) {
            throw new WebApplicationException("Event with Id of " + id + " Not Found");
        }
        //update
        foundEvent.title = event.title;
        return Response.ok(foundEvent.id + foundEvent.title + "has been modified").build();
    }

    @POST
    @Transactional
    public Response createEvent(Event event) {
        event.eventDate = new Date();
        event.persist();
        return Response.created(URI.create("/events/" + event.id)).build();
    }

    //inner class
    @Provider
    public class ErrorMapper implements ExceptionMapper<Exception> {
        @Override
        public Response toResponse(Exception exception) {
            return Response.status(500).entity(exception.getMessage()).build();
        }
    }
}
..............................................................................................
				Panche DAO /Repository Pattern
.............................................................................................

Loggers
Service Interaction -  HTTP Services
ReactiveProgamming -Muntiny
Vertx - Event driven architectures- EventBus



   
  






