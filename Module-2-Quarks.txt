					QuarKus
...........................................................................................
What is QuarKus?

 A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.

In Quarkus you can built  monolithic and micro servies apps which we can run directly on containers(kubernetes) and native(host) machines, on JVM as well.
..............................................................................................

Quarkus Programming Model:

1.Imperative Model
   -It is regular Programming model
2.Reactive Programming Model
   -Using Reactive Specification


Quarkus has been built on Java Specifications.

Types of specifications:

1.JSE -  Java Standard Edition
2.JEE -  Java Enteriprise Edition
3.JME  - Java Micro Edition

Who is offering these specification?

Java Community Process  is non profitable organization.


JCP releases : JSRs: Java Specification Requests

Java EE (54 JSRs)
The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.
The JSRs in this list are part of the Java EE platform as component or umbrella JSRs.

Java SE (69 JSRs)
The Java Standard Edition offers APIs and tools for developing desktop and server-side enterprise applications. The JSRs in this list are part of the Java SE platform as component or umbrella JSRs.

Java ME (85 JSRs)
Java ME technology, Java Micro Edition, specifically addresses the vast consumer space, which covers the range of extremely tiny commodities such as smart cards or a pager all the way up to the set-top box, an appliance almost as powerful as a computer.



JSE :
 -JavaTM Management Extensions (JMXTM) Specification
 -XML Parsing Specification
 -JDBC  Specification
 -Concurrency Utilities
- JSR-000384 JavaTM SE 11

Java EE (54 JSRs) :Quarkus has been built on the top of JEE Specification
-XML Parsing Specification
-Enterprise JavaBeans
-Java Servlet Spec
-JPA Spec
-JSON-B Spec
-Bean Validation
WebServices:
-JAX-RS - Building Resfull API
-JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
-JTA 
 -Container Specs 
    How to create Enterprise grade applications and how to deploy them
 JBOss,tomcat,weblogic,websphere are products based on contaner specs

Spec implementations:
-Frameworks like spring
-containers like tomcat,jboss,weblogic....

.............................................................................................
			Are we using JEE Spec and its implementations on a now days
.............................................................................................
                                         No!

Why JEE Spec failed In Modern Computing?
  
   JEE Spec was developed to build traditional Monolothic distributed,transactional, secure 
Applications


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

		Birth of Project called "MicroProfile"


MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.
Eclipse MicroProfile addresses the need for enterprise "java MicroService"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards

MicroProfile Implementations:
.............................

Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
...............................................................................................
                 Quarkus is built on top of various projects and standards

                Quarkus is built on Core JEE Standards and MicroProfile Standards


1.RestEasy  - framework built for JAX-RS Spec for building REST APIS
2.Hibernate and JPA  -Data Layer
3.Ecplise Micro Profile spec via SmallRye Framework

SmallRye Config
	An implementation of MicroProfile Config

SmallRye JWT
	An implementation of MicroProfile JWT RBAC

SmallRye Health
	An implementation of MicroProfile Health

SmallRye Fault Tolerance
	An implementation of MicroProfile Fault Tolerance

SmallRye Metrics
	An implementation of MicroProfile Metrics

SmallRye OpenAPI
	An implementation of MicroProfile OpenAPI

SmallRye OpenTracing
	An implementation of MicroProfile OpenTracing

RESTEasy REST Client
	An implementation of MicroProfile REST Client

4.Apache Camel

5.Reactive Programming via Rxjava and mutiny

6.Container  - Non blocking container -Netty

7.Web Container Nettty and Vertx Engine

etc.....

Container integration - kubernetes
Cloud Integration
.............................................................................................
                                    Quarkus Project Setup
..............................................................................................

Quarkus Build System:
 - Maven
 - Gradle

Software Req:

1.GrallVm
2.jdk 11
3.maven/gradle
4.IntelliJ idea / vscode
5.Docker

/////////////////////////////////////////////////////////////////////////////////////////////


Quarkus : First App


how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project creations

Way -1

mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"

cd getting-started


Way-2 :Interactive way to create Project
mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create 

Way-3 : via web portals

https://code.quarkus.io/

Way -4 : ide plugins
 via Intellij idea plugins


Running Quarkus :

1.Dev
2.Test
3.Production


How to write and Run Application?

Dev:
 ./mvnw compile quarkus:dev - linux /mac

 mvnw compile quarkus:dev  - windows

 mvn compile quarkus:dev

Dev features;

-Live coding Reloading
   if write code and save and referesh your browser / any tool

.............................................................................................

Run Application:

1.With JVM
  -Running app on JVM either in host machine or virtualized env - vms and containers
You need jar file

2.Without JVM
 -Running Application  directly  on host operating system or inside vms/containers


1.With JVM

jar file creation.

1.normal jar
2.fat jar / uber jar

Fat JAR:
A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies). ... Fat JARs are handy when you need to build an executable JAR file, e.g. a microservice executable

Packaging and running the application

The application can be packaged using:

```shell script
./mvnw package
```
It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.
Be aware that it’s not an _über-jar_ as the dependencies are copied into the `target/quarkus-app/lib/` directory.

If you want to build an _über-jar_, execute the following command:
```shell script
./mvnw package -Dquarkus.package.type=uber-jar
```

The application is now runnable using `java -jar target/quarkus-app/quarkus-run.jar`.


Lab Side :

1.Build normal jar  and test 
  $java -jar target/quarkus-app/quarkus-run.jar

2.Build fat 
./mvnw package -Dquarkus.package.type=uber-jar
The application is now runnable using 
`java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar`.

.............................................................................................

With JVM:

Native App:

How to convert Quarkus app into native binary and run ? without JVM


How to build Native Image?

There are multiple patterns

1.With installed GRALLVM Software

mvnw package -Pnative
    

GrallVM - BUild image - on os - myos1.0 -----

GrallVM - BUild image  myos2.0 ----


Note: 

if you are building image on windows

1.You must have installed GrallVm software before builiding image other wise it will throw error

Error: Default native-compiler executable 'cl.exe' not found via environment variable PATH
Error: To prevent native-toolchain checking provide command-line option -H:-CheckToolchain
com.oracle.svm.core.util.UserError$UserException: Default native-compiler executable 'cl.exe' not found via environment variable PATH
To prevent native-toolchain checking provide command-line option -H:-CheckToolchain

Please follow the url for installing grallvm in your local windows desktop:

https://www.graalvm.org/docs/getting-started/windows/

if you building image on linux

2.You must have installed GrallVM software on Linux

if you want to convert 

...................................................................................

Building Native Image using Docker 

mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker
..............................................................................................
				  GraallVM	
.............................................................................................

What is GraalVM?
  GraalVM is the next generation compiler to compile java and other code into native binary
to achive language interoperability.

GRALLVM provides a compiler call "Grall" 

 Grall is extension compiler works along with JVM - HOT SPOT

java  --grall App

GrallVM provides lot of tools to work with native images and other language

1.sulong: 
  Memory manager
2.Truffle Framework
   Language framework to run java like apps with out jvm,node,phython runtimes.
3.Grall Compiler  
    supports compiling java code statically, dynamically
4.JVM COMPILER interface
    to plugg grall compiler along with existing javac compiler
5.Java hotpot jvm
    Grallvm compiler + hot Spot + JIT + AOT

.......................................................................................
			      JVM
Hello.java -->Hello.class--|--ClassLoader---|SM---|init---|invokeDynamic---|Refelcetion,proxy| --|Class Object(meta Object)-----instance Creation---lives in memory-heap---


Mandrel
Mandrel is a downstream distribution of the GraalVM community edition. Mandrel's main goal is to provide a native-image release specifically to support Quarkus. 
The aim is to align the native-image capabilities from GraalVM with OpenJDK and Red Hat Enterprise Linux libraries to improve maintainability for native Quarkus applications.
.........................................................................................

Lab: Set up GraalVM : How to build native image?

Steps:

1.sudo apt-get update 

2.sudo apt-get install gcc zlib1g-dev build-essential

3.wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-21.0.0.2/graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

4.tar -xvzf graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

5.ls

6.sudo mkdir /usr/lib/jvm 
7.sudo mv graalvm-ce-java11-21.0.0.2/ /usr/lib/jvm

8.echo 'export PATH=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2/bin:$PATH' >> ~/.bashrc


9.echo 'export JAVA_HOME=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2' >> ~/.bashrc

10.logout

source ~/.bashrc

java -version 
gu install native-image
gu available 
javac HelloWorld.java
native-image HelloWorld
ls
./helloworld
.............................................................................................
How to Run  Quarkus Application?


1.Dev Mode
  mvnw compile

2.Production Mode

-Running on JVM On host
  -using Jar patterns
-Running on JVM On Container which run on Host/Cloud

-Running on Host without JVM
   -Using Native Image
How to build native Image out of Quarks App

- Build native binary using Docker Container, Here docker is build system to build native
   mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

-Build native binary using GrallVM Itself.

 mvnw package -Pnative

 To run this command we need GraalVM setup must be there in host machine or where we are building binary.

.............................................................................................

Lab : 

- create simple project

-Run
 -dev
package
 - jar
 -uber jar
 -native image
    -using docker build
         mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

    -using graalvm native build
	mvnw package -Pnative

/home/ramya/myquarkusapps / getting-started




















