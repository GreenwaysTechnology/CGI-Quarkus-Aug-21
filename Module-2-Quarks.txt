					QuarKus
...........................................................................................
What is QuarKus?

 A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.

In Quarkus you can built  monolithic and micro servies apps which we can run directly on containers(kubernetes) and native(host) machines, on JVM as well.
..............................................................................................

Quarkus Programming Model:

1.Imperative Model
   -It is regular Programming model
2.Reactive Programming Model
   -Using Reactive Specification


Quarkus has been built on Java Specifications.

Types of specifications:

1.JSE -  Java Standard Edition
2.JEE -  Java Enteriprise Edition
3.JME  - Java Micro Edition

Who is offering these specification?

Java Community Process  is non profitable organization.


JCP releases : JSRs: Java Specification Requests

Java EE (54 JSRs)
The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.
The JSRs in this list are part of the Java EE platform as component or umbrella JSRs.

Java SE (69 JSRs)
The Java Standard Edition offers APIs and tools for developing desktop and server-side enterprise applications. The JSRs in this list are part of the Java SE platform as component or umbrella JSRs.

Java ME (85 JSRs)
Java ME technology, Java Micro Edition, specifically addresses the vast consumer space, which covers the range of extremely tiny commodities such as smart cards or a pager all the way up to the set-top box, an appliance almost as powerful as a computer.



JSE :
 -JavaTM Management Extensions (JMXTM) Specification
 -XML Parsing Specification
 -JDBC  Specification
 -Concurrency Utilities
- JSR-000384 JavaTM SE 11

Java EE (54 JSRs) :Quarkus has been built on the top of JEE Specification
-XML Parsing Specification
-Enterprise JavaBeans
-Java Servlet Spec
-JPA Spec
-JSON-B Spec
-Bean Validation
WebServices:
-JAX-RS - Building Resfull API
-JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
-JTA 
 -Container Specs 
    How to create Enterprise grade applications and how to deploy them
 JBOss,tomcat,weblogic,websphere are products based on contaner specs

Spec implementations:
-Frameworks like spring
-containers like tomcat,jboss,weblogic....

.............................................................................................
			Are we using JEE Spec and its implementations on a now days
.............................................................................................
                                         No!

Why JEE Spec failed In Modern Computing?
  
   JEE Spec was developed to build traditional Monolothic distributed,transactional, secure 
Applications


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

		Birth of Project called "MicroProfile"


MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.
Eclipse MicroProfile addresses the need for enterprise "java MicroService"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards

MicroProfile Implementations:
.............................

Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
...............................................................................................
                 Quarkus is built on top of various projects and standards

                Quarkus is built on Core JEE Standards and MicroProfile Standards


1.RestEasy  - framework built for JAX-RS Spec for building REST APIS
2.Hibernate and JPA  -Data Layer
3.Ecplise Micro Profile spec via SmallRye Framework

SmallRye Config
	An implementation of MicroProfile Config

SmallRye JWT
	An implementation of MicroProfile JWT RBAC

SmallRye Health
	An implementation of MicroProfile Health

SmallRye Fault Tolerance
	An implementation of MicroProfile Fault Tolerance

SmallRye Metrics
	An implementation of MicroProfile Metrics

SmallRye OpenAPI
	An implementation of MicroProfile OpenAPI

SmallRye OpenTracing
	An implementation of MicroProfile OpenTracing

RESTEasy REST Client
	An implementation of MicroProfile REST Client

4.Apache Camel

5.Reactive Programming via Rxjava and mutiny

6.Container  - Non blocking container -Netty

7.Web Container Nettty and Vertx Engine

etc.....

Container integration - kubernetes
Cloud Integration
.............................................................................................
                                    Quarkus Project Setup
..............................................................................................

Quarkus Build System:
 - Maven
 - Gradle

Software Req:

1.GrallVm
2.jdk 11
3.maven/gradle
4.IntelliJ idea / vscode
5.Docker

/////////////////////////////////////////////////////////////////////////////////////////////


Quarkus : First App


how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project creations

Way -1

mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"

cd getting-started


Way-2 :Interactive way to create Project
mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create 

Way-3 : via web portals

https://code.quarkus.io/

Way -4 : ide plugins
 via Intellij idea plugins


Running Quarkus :

1.Dev
2.Test
3.Production


How to write and Run Application?

Dev:
 ./mvnw compile quarkus:dev - linux /mac

 mvnw compile quarkus:dev  - windows

 mvn compile quarkus:dev

Dev features;

-Live coding Reloading
   if write code and save and referesh your browser / any tool

.............................................................................................

Run Application:

1.With JVM
  -Running app on JVM either in host machine or virtualized env - vms and containers
You need jar file

2.Without JVM
 -Running Application  directly  on host operating system or inside vms/containers


1.With JVM

jar file creation.

1.normal jar
2.fat jar / uber jar

Fat JAR:
A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies). ... Fat JARs are handy when you need to build an executable JAR file, e.g. a microservice executable

Packaging and running the application

The application can be packaged using:

```shell script
./mvnw package
```
It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.
Be aware that it’s not an _über-jar_ as the dependencies are copied into the `target/quarkus-app/lib/` directory.

If you want to build an _über-jar_, execute the following command:
```shell script
./mvnw package -Dquarkus.package.type=uber-jar
```

The application is now runnable using `java -jar target/quarkus-app/quarkus-run.jar`.


Lab Side :

1.Build normal jar  and test 
  $java -jar target/quarkus-app/quarkus-run.jar

2.Build fat 
./mvnw package -Dquarkus.package.type=uber-jar
The application is now runnable using 
$java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar

.............................................................................................

With JVM:

Native App:

How to convert Quarkus app into native binary and run ? without JVM


How to build Native Image?

There are multiple patterns

1.With installed GRALLVM Software

mvnw package -Pnative
    

GrallVM - BUild image - on os - myos1.0 -----

GrallVM - BUild image  myos2.0 ----


Note: 

if you are building image on windows

1.You must have installed GrallVm software before builiding image other wise it will throw error

Error: Default native-compiler executable 'cl.exe' not found via environment variable PATH
Error: To prevent native-toolchain checking provide command-line option -H:-CheckToolchain
com.oracle.svm.core.util.UserError$UserException: Default native-compiler executable 'cl.exe' not found via environment variable PATH
To prevent native-toolchain checking provide command-line option -H:-CheckToolchain

Please follow the url for installing grallvm in your local windows desktop:

https://www.graalvm.org/docs/getting-started/windows/

if you building image on linux

2.You must have installed GrallVM software on Linux

if you want to convert 

...................................................................................

Building Native Image using Docker 

mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker
..............................................................................................
				  GraallVM	
.............................................................................................

What is GraalVM?
  GraalVM is the next generation compiler to compile java and other code into native binary
to achive language interoperability.

GRALLVM provides a compiler call "Grall" 

 Grall is extension compiler works along with JVM - HOT SPOT

java  --grall App

GrallVM provides lot of tools to work with native images and other language

1.sulong: 
  Memory manager
2.Truffle Framework
   Language framework to run java like apps with out jvm,node,phython runtimes.
3.Grall Compiler  
    supports compiling java code statically, dynamically
4.JVM COMPILER interface
    to plugg grall compiler along with existing javac compiler
5.Java hotpot jvm
    Grallvm compiler + hot Spot + JIT + AOT

.......................................................................................
			      JVM
Hello.java -->Hello.class--|--ClassLoader---|SM---|init---|invokeDynamic---|Refelcetion,proxy| --|Class Object(meta Object)-----instance Creation---lives in memory-heap---


Mandrel
Mandrel is a downstream distribution of the GraalVM community edition. Mandrel's main goal is to provide a native-image release specifically to support Quarkus. 
The aim is to align the native-image capabilities from GraalVM with OpenJDK and Red Hat Enterprise Linux libraries to improve maintainability for native Quarkus applications.
.........................................................................................

Lab: Set up GraalVM : How to build native image?

Steps:

1.sudo apt-get update 

2.sudo apt-get install gcc zlib1g-dev build-essential

3.wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-21.0.0.2/graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

4.tar -xvzf graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

5.ls

6.sudo mkdir /usr/lib/jvm 
7.sudo mv graalvm-ce-java11-21.0.0.2/ /usr/lib/jvm

8.echo 'export PATH=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2/bin:$PATH' >> ~/.bashrc


9.echo 'export JAVA_HOME=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2' >> ~/.bashrc

10.logout

11.source ~/.bashrc

12.java -version 
13.gu install native-image
14.gu available 
15.javac HelloWorld.java
16.native-image HelloWorld
17.ls
./helloworld
.............................................................................................
How to Run  Quarkus Application?


1.Dev Mode
  mvnw compile

2.Production Mode

-Running on JVM On host
  -using Jar patterns
-Running on JVM On Container which run on Host/Cloud

-Running on Host without JVM
   -Using Native Image
How to build native Image out of Quarks App

- Build native binary using Docker Container, Here docker is build system to build native
   mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

-Build native binary using GrallVM Itself.

 mvnw package -Pnative

 To run this command we need GraalVM setup must be there in host machine or where we are building binary.

.............................................................................................

Lab : 

- create simple project

-Run
 -dev
package
 - jar
 -uber jar
 -native image
    -using docker build
         mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

    -using graalvm native build
	mvnw package -Pnative

/home/ramya/myquarkusapps / getting-started
..............................................................................................
					Quarkus Modules
..............................................................................................

Modules:

1.core
2.web
3.data
4.microservies
5.cloud
6.security
..............................................................................................
					Web Module
..............................................................................................

Web Module : 

 Restfull Web Services : HTTP based Micro Services

Quarkus has been built on JEE Standards

Web Service Standards:

1.JAX-RS - Building Restfull api 
2.JAX-WS - SOA -Soap and XML based Web Services

JAX-RS 
 Spec Doc url : https://download.oracle.com/otn-pub/jcp/jaxrs-2_0-fr-eval-spec/jsr339-jaxrs-2.0-final-spec.pdf?AuthParam=1628233398_2da58a3072d802256d822163050b633f

Apache RestEasy Framework which implements JAX-RS spec.

Apache RestEasy implements even MicroProfile Spec as well
 -Config Spec
 -WebClient Spec

Quarkus abstracts or implements Apache RestEasy implementation.


maven Dependancy:
<dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy</artifactId>
</dependency>

RESTFull WebServices:
.....................

Representational State Transfer (REST)


Representational :
  The Data Format.
  Data is encaspulted inside object , object can be transfered into format and send over network.

  Java Object -----|XML /JSON(Representation)------send over network-----|Parsing---| Object

   Object to String
   String to Object


State : 
   Object state - OBject data

Transfer 
  Moving from one place to another.

.............................................................................................

How to begin Restfull Web Service based distributed App?

1.Identifying Model(Object)-Domain Object

 eg:
  Customer,Order,Inventory,Products,Items

2.Resources
   
    Program, having apis , gets exectued when ever request comes for accessing object.

 In java Resource is class.

   public class OrderResource{

   }
   public class CustomerResource{

   }

    public class ProductResource{

   }

Coding Standard according jax-rs spec

  Any resource class must be 
  
  -meaningfull to the domain model
     Order
  -Noun
      Order
  -Should have suffix Resource
      OrderResource  
  

3.Model URI

 URI - Uniform Resource Identifier.

 /api/orders
 /api/customers
 /api/orders/1
 /api/products/1
 

Client(Could be  humman being or anythoer system(app)) wants data from Distributed System.

Client-----------request(want)---------System---Running on Another Software(WebContainer)---Runs Resources

HTTP Protocal:
..............

What is Protocal?

  In Computer, where ever you transfer data , there is protocal.

http://identification:port/resource/subreource
https://
jdbc://
soap://
c:/
ftp://
 |
scheme

 
What is HTTP Protocal?
  
 It is set of rules for transfering web documents(html,img,videos,docs,pdf,json,xml) over internet.
  -Type of web document identified by - application/xxx - Media Type

How to represent http protocal?
  
is it software /hardware?

HTTP is Program written in C langauge

HTTP Program types

1.HttpRequest.c
2.HttpResponse.c
3.HttpSocket.c

Program contain two things:

1.Variables 
2.Methods/functions

HTTP Program also contains 

variables
    - HTTP headers - content-type,auth,cookie,date.....
methods
    - functions are called HTTP methods

 get,post,put,delete,trace,options,head............

 void main(){

     int * get(args) {
	logic.... for get-- read operations
     }
 }

Web Server:
  It is program which calls http functions

Flow of HTTP

Client GET /api/resource----------------|WebServer----function get() { 
							return "something" // response
						       }


HTTP Programming Models:

In 1996, Many Companies wanted to abstract http  layer to build http driven distributed apps

- J2EE -  Servlet--- Abstraction on HTTP Core apis
- ASP - Microsoft
- PHP

REST also uses exsiting http arch.

JAX-RS is spec to design REST based web app using annotations.


JAX-RS Annotations:

1.Resource Identifier
 
@Path

2.HTTP Method Binding
 
@GET,@POST,@PUT,@DELETE,@TRACE



REST Resource:

package org.cgi.getting.started;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/hello")
public class GreetingResource {
    @GET
    public String sayHello() {
        return "Hello";
    }
}

PATH Design
Responses
Negotiation

 -Content - json,xml...
 -Language
 -Encoding
..............................................................................................

HTTP Resources and Methods:
...........................

Use case :  How to design Resource with HTTP methods.


@Path:

 -Annotation can be used at class Level - Root Resource
 -Annotation can be used at method level - Nested Resource

/mainresource/subresource
  |             |
class         method

GET:
  GET is a read-only operation. 
  It is used to query the server for specific information.
  It is both an idempotent and safe operation. 

Idempotent means that 
  no matter how many times you apply the operation, the result is always the same.

Safe means that
invoking a GET does not change the state of the server at all. This means that, other
than request load, the operation will not affect the server.




Client asks that give me some thing (document,image,pdf,data).

Client sends request(instruction)----------http----------------|WebServer - will call method 							-Get Method(function)---will do some 							 io operation --read image file----
							 Write into outputstream(response)
Client will Recive Response <-----------------------------------------
    


Every Resource must have mapped at least one http method mapping.


package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }
}


Without @GET, it will cause an error.

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    
    public String getUser(){
        return "Subramanian";
    }
}

What if a uri points multiple methods having Same Request HTTP Method.

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    public String getInfo(){
        return "Info";
    }
}

Look at console
2021-08-09 13:42:48,400 WARN  [org.jbo.res.res.i18n] (executor-thread-0) RESTEASY002142: Multiple resource methods match request "GET /users". Selecting one. Matching methods: [public java.lang.String com.cgi.rest.UserResource.getUser(), public java.lang.String com.cgi.rest.UserResource.getInfo()]

Resoult would be last method result.

info

How to use @Resource at method level and class Level

package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }
}

What if @Path is not used at class level?

package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

public class UserResource {

    @GET
    @Path("/users")
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }
}

//http://localhost:8080/users

We will get 404 -Resource Not Found Error.
..........................................................................................

PUT:
    Requests that the server store the message body sent with the request under
the location provided in the HTTP message.

It is usually modeled as an insert or update.
It is also idempotent.

POST
    POST is the only nonidempotent and unsafe operation of HTTP.

Each POST method is allowed to modify the service in a unique way.
You may or may not send information with the request.
You may or may not receive information from the response.

DELETE
  DELETE is used to remove resources. 
  It is idempotent as well.


HEAD
  HEAD is exactly like GET except that instead of returning a response body, it
returns only a response code and any headers associated with the request.

OPTIONS

 OPTIONS is used to request information about the communication options of the
resource you are interested in. 
It allows the client to determine the capabilities of a server and a resource without triggering any resource action or retrieval.


package com.cgi.rest;

import javax.ws.rs.*;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }

    @PUT
    public String updateUser(){
        return "Updated";
    }

    @POST
    public String save(){
        return  "saved";
    }
    @DELETE
    public String remove(){
        return "Removed";
    }
}
..............................................................................................
				  JAX-RS Injection
.............................................................................................

What is injection?

 JAX-RS is pulling information from an HTTP request and injecting it into a java method.

We can get information after injection

-Fragement of incoming URI
-QueryString in a URI.
-The client might be sending some critical HTTP headers(request Header) or cookie values.

How to inject jax-rs annotations.

-@PathParam
-@MatrixParam
-@QueryParam
-@HeaderParam
-@FormParam
-@CookieParam
-@Context


@PathParam: 
  is used to form dynamic URI
/products/1 - here 1 is dynamic
i want to return product information having id 1.

@Path("{id}")
@Path("/products/{id}")


Use case : how to use path param , inject pathparam and read values
package com.cgi.res.params.path;


import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/library")
public class LibraryResource {

    @GET
    public String getBooks(){
        return "Books";
    }

    //library/book/123345
    @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") String isbn){
        return "Book by isbn" + isbn;
    }
   
}

Use case : if path param uri looks like different but which shares same url pattern

Note : Method Selection always based on URL Patterns not method signature


  @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") int isbn){
        return "Book by isbn" + isbn;
    }
    @GET
    @Path("/book/{authorName}")
    public String getAuthor(@PathParam("authorName") String authorName){
        return "Author - " + authorName;
    }

This code will match always the first one , second one will be skipped.

package com.cgi.res.params.path;


import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/library")
public class LibraryResource {

    @GET
    public String getBooks(){
        return "Books";
    }

    //library/book/123345
    @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") int isbn){
        return "Book by isbn" + isbn;
    }
    @GET
    @Path("/book/author/{authorName}")
    public String getAuthor(@PathParam("authorName") String authorName){
        return "Author - " + authorName;
    }
}
.............................................................................................
			    Path Design using Regular Expressions
.............................................................................................

Regular expression is one of the most popular text processing patterns

https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html


The @Path template variable is not limited to a fixed string expression, we can also use regular expressions for them. The regex must be a valid expression per Java regex specs.

By default, the URI variable must match the regular expression "[^/]+?".

That means a path of one or more characters value will match, also the leading '/' is always ignored, so it's not necessary to always put a leading '/' in path variable names.

Syntax for using regex
@Path("fixedPart/{variable: regex}")

The following example restrict user name to be only of lowercase and uppercase alphanumeric characters.

@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")


package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("/users")
public class UserResource {

    /**
     *@Path("list/{userName:[a-zA-Z][a-zA-Z_0-9]*}")
     * valid urls
     * localhost:8080/users/list/Subramanian
     * localhost:8080/users/list/SUBRAMANIAN
     * localhost:8080/users/list/SUBRAM12333ANIAN
     *  @Path("list/{userName:[a-zA-Z]*}")
     *  valid urls:
     *  localhost:8080/users/list/SUBRAMANIAN
     */
    @GET
    //@Path("list/{userName:[a-zA-Z][a-zA-Z_0-9]*}")
    @Path("list/{userName:[a-zA-Z]*}")
    public String getUser(@PathParam("userName") String userName) {
        return "User Name Regex" + userName;
    }
}
.............................................................................................
				    Query Parameters
.............................................................................................

@QueryParam :
 It is used to read request parameter which was supplied via Query Strings

 GET /books?num=5
 GET /customers?start=1&size=10
package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;

@Path("/queryresource")
public class QueryParamResource {

//localhost:8080/queryresource?num=10&start=1&size=100
    @GET
    public String getQueryParam(@QueryParam("num") int num, @QueryParam("start") int start, @QueryParam("size") int size) {
        return "Query Params" + num + " " + start + " " + size;
    }
}
........................................................................
What if i have more parameters? i have to inject into method in order to access all parameters
We have short cut to read all parameters using One Object.
............................................................................................
				  Context Object
............................................................................................

Context Object represents "container". Using context object we can access many information.

Information:

javax.ws.rs.core
1.HttpHeaders
2.UriInfo
3.Request
4.HttpServletRequest - ServletRequest
5.HttpServletResponse
6.ServletConfig
7.ServletContext
8.SecurityContext
............................................................................................
                             Accssing Query Params using Context
.............................................................................................


package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.UriInfo;

@Path("/queryresource")
public class QueryParamResource {
    @GET
    public String getQueryParam(@QueryParam("num") int num, @QueryParam("start") int start, @QueryParam("size") int size) {
        return "Query Params" + num + " " + start + " " + size;
    }

    //localhost:8080/queryresource/ctx?num=10&start=1&size=100
    @GET
    @Path("ctx")
    public String getQueryParamUsingContext(@Context UriInfo uriInfo){
        String num = uriInfo.getQueryParameters().getFirst("num");
        String start =uriInfo.getQueryParameters().getFirst("start");
        String size = uriInfo.getQueryParameters().getFirst("size");
        return "Query Params using ctx " +  num + " " + start + " " + size;
    }
}
..............................................................................................
				 Matrix Parameters

Matrix Parameter is used along with Path Parameter, in order to add more values for given path.

Car Information:

/car/{make}/{model}/{year}

/car/mercedes/e55;color=black/2008
		    |
		 Matrix Parameter

To read Matrix Parameter value @MatrixParam("color") String color

package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.MatrixParam;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("/car/{make}")
public class CarResource {

    //localhost:8080/car/mercedes/e55;color=black/2008
    @GET
    @Path("/{model}/{year}")
    public String getCarInfo(@MatrixParam("color") String color,
                             @PathParam("make") String make,
                             @PathParam("model") String model,
                             @PathParam("year") String year
    ) {

        return "Car " + color + make + model + year;
    }
}
..............................................................................................
				Header Parameter
                                  @HeaderParam

This annotation is used to inject http request header values.
For eg : Server is interested to know or read all client http request headers
like content type,accept,language,encoding,client details....

package com.cgi.rest.params;

import org.jboss.resteasy.annotations.jaxrs.HeaderParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import java.util.Set;

@Path("/headers")
public class HeaderParamResource {

    @GET
    public String getHeaderInfo(@HeaderParam("Content-Type") String contentType ,@HeaderParam("Accept") String acceptType){
            return "Header" + contentType + " " + acceptType;
    }
    @GET
    @Path("/all")
    public String getAllHeaders(@Context HttpHeaders httpHeaders){
        //print only headers and not values - keySet returns only key portion
        httpHeaders.getRequestHeaders().keySet().forEach(header->{
            System.out.println(header);
        });
         return "all";
    }
}
.................................................................................................
				Cookie Params
.............................................................................................

if you want to read cookie and send cookie

we can use @CookieParam to read cookie value.

cookie is used to exchange information between client and server for unquie identification.


Steps:

1.Server should send cookie to the client

2.Client should send the same cookie to the server
  
From the server , if i want read cookie sent by client -@CookieParam 

package com.cgi.rest.params;

import javax.ws.rs.CookieParam;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.NewCookie;
import javax.ws.rs.core.Response;

@Path("/login")
public class CookieParamResource {

    //send cook
    @GET
    @Path("/createcookie")
    public Response createCookie(@QueryParam("userName") String userName) {
//        NewCookie cookie = new NewCookie("userName", "Subramanian");
        NewCookie cookie = new NewCookie("userName", userName);

        //send cookie to the client
        return Response.ok("cookie sent").cookie(cookie).build();
    }

    @GET
    public String getCookie(@CookieParam("userName") String userName) {
        return "Cookie Name " + userName;
    }

}
.............................................................................................
				 Sending Data via Forms
.............................................................................................


Form data can be sent to the server , via "Payload-body".

When the input request body is of the type "application/x-www-form-urlencoded" , aka html form,you can collect data into one single payload looks like an object, send to the the server.

Now server can extract form parameters from the "Payload" using @FormParam

<form method="post" action="resource/form">
   <input type="text" name="firstName">
   <input type="text" name="lastName">
</form>
We are going to use post man to send form data.


package com.cgi.rest.params;

import javax.ws.rs.FormParam;
import javax.ws.rs.POST;
import javax.ws.rs.Path;

@Path("/register")
public class RegisterationFormResource {


    @POST
    @Path("/save")
        public String save(@FormParam("firstName") String firstName, @FormParam("lastName") String lastName) {
        return "Form saved" + firstName + lastName;
    }

}
...........................................................................................
				 @DefaultValue
...........................................................................................
@DefaultValue is a parameter annotation that can be combined with any of the other @*Param
annotations to define a default value when the HTTP request item does not exits.

eg:

GET /book?num=10 

public ReturnType getBook(@QueryParam("num") int num) {


}

package com.cgi.rest.params;

import javax.ws.rs.*;

@Path("/book")
public class DefaultParamResource {

    @GET
    public String getQueryParam(@QueryParam("num") @DefaultValue("10") int num) {
        return "Query " + num;
    }

//    @GET
//    @Path("{id}")
//    public String getPathParam(@PathParam("id") @DefaultValue("100") int id) {
//        return id + "";
//    }
}
.............................................................................................
			        Resource Locators and Sub Resources
............................................................................................

Main resource:

ShoppingApp.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.Path;

@Path("/cgi/api")
public class ShoppingApp {

    @Path("/customers")
    public CustomerResource getCustomer() {
        return new CustomerResource();
    }

    @Path("/payments")
    public PaymentResource getPayment() {
        return new PaymentResource();
    }
}

CustomerResource.java
package com.cgi.rest.resourcelocators;


import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class CustomerResource {

    @GET
    public String getCustomers() {
        return "customers resource";
    }

    @GET
    @Path("{id}")
    public String getCustomerById(@PathParam("id") String id) {
        return "customers resource by id" + id;
    }
}

PaymentResource.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class PaymentResource {
    @GET
    public String getPayment() {
        return "Payment resource";
    }

    @GET
    @Path("{id}")
    public String getPayment(@PathParam("id") String id) {
        return "Payment resource by id" + id;
    }

    @Path("/creditcard")
    public CreditCardResource getCreditCard(){
          return new CreditCardResource();
    }

}

CreditCardResource.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.GET;

public class CreditCardResource {
    @GET
    public String getCreditCardDetails() {
        return "Credit Details";
    }
}
..............................................................................................

How to send data to Server?

1.via Parameters - path,query,matrix,cookie
2.via forms - payload(body)
3.via payloads- submit xml,json...











