					QuarKus
...........................................................................................
What is QuarKus?

 A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.

In Quarkus you can built  monolithic and micro servies apps which we can run directly on containers(kubernetes) and native(host) machines, on JVM as well.
..............................................................................................

Quarkus Programming Model:

1.Imperative Model
   -It is regular Programming model
2.Reactive Programming Model
   -Using Reactive Specification


Quarkus has been built on Java Specifications.

Types of specifications:

1.JSE -  Java Standard Edition
2.JEE -  Java Enteriprise Edition
3.JME  - Java Micro Edition

Who is offering these specification?

Java Community Process  is non profitable organization.


JCP releases : JSRs: Java Specification Requests

Java EE (54 JSRs)
The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.
The JSRs in this list are part of the Java EE platform as component or umbrella JSRs.

Java SE (69 JSRs)
The Java Standard Edition offers APIs and tools for developing desktop and server-side enterprise applications. The JSRs in this list are part of the Java SE platform as component or umbrella JSRs.

Java ME (85 JSRs)
Java ME technology, Java Micro Edition, specifically addresses the vast consumer space, which covers the range of extremely tiny commodities such as smart cards or a pager all the way up to the set-top box, an appliance almost as powerful as a computer.



JSE :
 -JavaTM Management Extensions (JMXTM) Specification
 -XML Parsing Specification
 -JDBC  Specification
 -Concurrency Utilities
- JSR-000384 JavaTM SE 11

Java EE (54 JSRs) :Quarkus has been built on the top of JEE Specification
-XML Parsing Specification
-Enterprise JavaBeans
-Java Servlet Spec
-JPA Spec
-JSON-B Spec
-Bean Validation
WebServices:
-JAX-RS - Building Resfull API
-JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
-JTA 
 -Container Specs 
    How to create Enterprise grade applications and how to deploy them
 JBOss,tomcat,weblogic,websphere are products based on contaner specs

Spec implementations:
-Frameworks like spring
-containers like tomcat,jboss,weblogic....

.............................................................................................
			Are we using JEE Spec and its implementations on a now days
.............................................................................................
                                         No!

Why JEE Spec failed In Modern Computing?
  
   JEE Spec was developed to build traditional Monolothic distributed,transactional, secure 
Applications


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

		Birth of Project called "MicroProfile"


MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.
Eclipse MicroProfile addresses the need for enterprise "java MicroService"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards

MicroProfile Implementations:
.............................

Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
...............................................................................................
                 Quarkus is built on top of various projects and standards

                Quarkus is built on Core JEE Standards and MicroProfile Standards


1.RestEasy  - framework built for JAX-RS Spec for building REST APIS
2.Hibernate and JPA  -Data Layer
3.Ecplise Micro Profile spec via SmallRye Framework

SmallRye Config
	An implementation of MicroProfile Config

SmallRye JWT
	An implementation of MicroProfile JWT RBAC

SmallRye Health
	An implementation of MicroProfile Health

SmallRye Fault Tolerance
	An implementation of MicroProfile Fault Tolerance

SmallRye Metrics
	An implementation of MicroProfile Metrics

SmallRye OpenAPI
	An implementation of MicroProfile OpenAPI

SmallRye OpenTracing
	An implementation of MicroProfile OpenTracing

RESTEasy REST Client
	An implementation of MicroProfile REST Client

4.Apache Camel

5.Reactive Programming via Rxjava and mutiny

6.Container  - Non blocking container -Netty

7.Web Container Nettty and Vertx Engine

etc.....

Container integration - kubernetes
Cloud Integration
.............................................................................................
                                    Quarkus Project Setup
..............................................................................................

Quarkus Build System:
 - Maven
 - Gradle

Software Req:

1.GrallVm
2.jdk 11
3.maven/gradle
4.IntelliJ idea / vscode
5.Docker

/////////////////////////////////////////////////////////////////////////////////////////////


Quarkus : First App


how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project creations

Way -1

mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"

cd getting-started


Way-2 :Interactive way to create Project
mvn io.quarkus:quarkus-maven-plugin:2.1.0.Final:create 

Way-3 : via web portals

https://code.quarkus.io/

Way -4 : ide plugins
 via Intellij idea plugins


Running Quarkus :

1.Dev
2.Test
3.Production


How to write and Run Application?

Dev:
 ./mvnw compile quarkus:dev - linux /mac

 mvnw compile quarkus:dev  - windows

 mvn compile quarkus:dev

Dev features;

-Live coding Reloading
   if write code and save and referesh your browser / any tool

.............................................................................................

Run Application:

1.With JVM
  -Running app on JVM either in host machine or virtualized env - vms and containers
You need jar file

2.Without JVM
 -Running Application  directly  on host operating system or inside vms/containers


1.With JVM

jar file creation.

1.normal jar
2.fat jar / uber jar

Fat JAR:
A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies). ... Fat JARs are handy when you need to build an executable JAR file, e.g. a microservice executable

Packaging and running the application

The application can be packaged using:

```shell script
./mvnw package
```
It produces the `quarkus-run.jar` file in the `target/quarkus-app/` directory.
Be aware that it‚Äôs not an _√ºber-jar_ as the dependencies are copied into the `target/quarkus-app/lib/` directory.

If you want to build an _√ºber-jar_, execute the following command:
```shell script
./mvnw package -Dquarkus.package.type=uber-jar
```

The application is now runnable using `java -jar target/quarkus-app/quarkus-run.jar`.


Lab Side :

1.Build normal jar  and test 
  $java -jar target/quarkus-app/quarkus-run.jar

2.Build fat 
./mvnw package -Dquarkus.package.type=uber-jar
The application is now runnable using 
$java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar

.............................................................................................

With JVM:

Native App:

How to convert Quarkus app into native binary and run ? without JVM


How to build Native Image?

There are multiple patterns

1.With installed GRALLVM Software

mvnw package -Pnative
    

GrallVM - BUild image - on os - myos1.0 -----

GrallVM - BUild image  myos2.0 ----


Note: 

if you are building image on windows

1.You must have installed GrallVm software before builiding image other wise it will throw error

Error: Default native-compiler executable 'cl.exe' not found via environment variable PATH
Error: To prevent native-toolchain checking provide command-line option -H:-CheckToolchain
com.oracle.svm.core.util.UserError$UserException: Default native-compiler executable 'cl.exe' not found via environment variable PATH
To prevent native-toolchain checking provide command-line option -H:-CheckToolchain

Please follow the url for installing grallvm in your local windows desktop:

https://www.graalvm.org/docs/getting-started/windows/

if you building image on linux

2.You must have installed GrallVM software on Linux

if you want to convert 

...................................................................................

Building Native Image using Docker 

mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker
..............................................................................................
				  GraallVM	
.............................................................................................

What is GraalVM?
  GraalVM is the next generation compiler to compile java and other code into native binary
to achive language interoperability.

GRALLVM provides a compiler call "Grall" 

 Grall is extension compiler works along with JVM - HOT SPOT

java  --grall App

GrallVM provides lot of tools to work with native images and other language

1.sulong: 
  Memory manager
2.Truffle Framework
   Language framework to run java like apps with out jvm,node,phython runtimes.
3.Grall Compiler  
    supports compiling java code statically, dynamically
4.JVM COMPILER interface
    to plugg grall compiler along with existing javac compiler
5.Java hotpot jvm
    Grallvm compiler + hot Spot + JIT + AOT

.......................................................................................
			      JVM
Hello.java -->Hello.class--|--ClassLoader---|SM---|init---|invokeDynamic---|Refelcetion,proxy| --|Class Object(meta Object)-----instance Creation---lives in memory-heap---


Mandrel
Mandrel is a downstream distribution of the GraalVM community edition. Mandrel's main goal is to provide a native-image release specifically to support Quarkus. 
The aim is to align the native-image capabilities from GraalVM with OpenJDK and Red Hat Enterprise Linux libraries to improve maintainability for native Quarkus applications.
.........................................................................................

Lab: Set up GraalVM : How to build native image?

Steps:

1.sudo apt-get update 

2.sudo apt-get install gcc zlib1g-dev build-essential

3.wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-21.0.0.2/graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

4.tar -xvzf graalvm-ce-java11-linux-amd64-21.0.0.2.tar.gz

5.ls

6.sudo mkdir /usr/lib/jvm 
7.sudo mv graalvm-ce-java11-21.0.0.2/ /usr/lib/jvm

8.echo 'export PATH=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2/bin:$PATH' >> ~/.bashrc


9.echo 'export JAVA_HOME=/usr/lib/jvm/graalvm-ce-java11-21.0.0.2' >> ~/.bashrc

10.logout

11.source ~/.bashrc

12.java -version 
13.gu install native-image
14.gu available 
15.javac HelloWorld.java
16.native-image HelloWorld
17.ls
./helloworld
.............................................................................................
How to Run  Quarkus Application?


1.Dev Mode
  mvnw compile

2.Production Mode

-Running on JVM On host
  -using Jar patterns
-Running on JVM On Container which run on Host/Cloud

-Running on Host without JVM
   -Using Native Image
How to build native Image out of Quarks App

- Build native binary using Docker Container, Here docker is build system to build native
   mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

-Build native binary using GrallVM Itself.

 mvnw package -Pnative

 To run this command we need GraalVM setup must be there in host machine or where we are building binary.

.............................................................................................

Lab : 

- create simple project

-Run
 -dev
package
 - jar
 -uber jar
 -native image
    -using docker build
         mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker

    -using graalvm native build
	mvnw package -Pnative

/home/ramya/myquarkusapps / getting-started
..............................................................................................
					Quarkus Modules
..............................................................................................

Modules:

1.core
2.web
3.data
4.microservies
5.cloud
6.security
..............................................................................................
					Web Module
..............................................................................................

Web Module : 

 Restfull Web Services : HTTP based Micro Services

Quarkus has been built on JEE Standards

Web Service Standards:

1.JAX-RS - Building Restfull api 
2.JAX-WS - SOA -Soap and XML based Web Services

JAX-RS 
 Spec Doc url : https://download.oracle.com/otn-pub/jcp/jaxrs-2_0-fr-eval-spec/jsr339-jaxrs-2.0-final-spec.pdf?AuthParam=1628233398_2da58a3072d802256d822163050b633f

Apache RestEasy Framework which implements JAX-RS spec.

Apache RestEasy implements even MicroProfile Spec as well
 -Config Spec
 -WebClient Spec

Quarkus abstracts or implements Apache RestEasy implementation.


maven Dependancy:
<dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy</artifactId>
</dependency>

RESTFull WebServices:
.....................

Representational State Transfer (REST)


Representational :
  The Data Format.
  Data is encaspulted inside object , object can be transfered into format and send over network.

  Java Object -----|XML /JSON(Representation)------send over network-----|Parsing---| Object

   Object to String
   String to Object


State : 
   Object state - OBject data

Transfer 
  Moving from one place to another.

.............................................................................................

How to begin Restfull Web Service based distributed App?

1.Identifying Model(Object)-Domain Object

 eg:
  Customer,Order,Inventory,Products,Items

2.Resources
   
    Program, having apis , gets exectued when ever request comes for accessing object.

 In java Resource is class.

   public class OrderResource{

   }
   public class CustomerResource{

   }

    public class ProductResource{

   }

Coding Standard according jax-rs spec

  Any resource class must be 
  
  -meaningfull to the domain model
     Order
  -Noun
      Order
  -Should have suffix Resource
      OrderResource  
  

3.Model URI

 URI - Uniform Resource Identifier.

 /api/orders
 /api/customers
 /api/orders/1
 /api/products/1
 

Client(Could be  humman being or anythoer system(app)) wants data from Distributed System.

Client-----------request(want)---------System---Running on Another Software(WebContainer)---Runs Resources

HTTP Protocal:
..............

What is Protocal?

  In Computer, where ever you transfer data , there is protocal.

http://identification:port/resource/subreource
https://
jdbc://
soap://
c:/
ftp://
 |
scheme

 
What is HTTP Protocal?
  
 It is set of rules for transfering web documents(html,img,videos,docs,pdf,json,xml) over internet.
  -Type of web document identified by - application/xxx - Media Type

How to represent http protocal?
  
is it software /hardware?

HTTP is Program written in C langauge

HTTP Program types

1.HttpRequest.c
2.HttpResponse.c
3.HttpSocket.c

Program contain two things:

1.Variables 
2.Methods/functions

HTTP Program also contains 

variables
    - HTTP headers - content-type,auth,cookie,date.....
methods
    - functions are called HTTP methods

 get,post,put,delete,trace,options,head............

 void main(){

     int * get(args) {
	logic.... for get-- read operations
     }
 }

Web Server:
  It is program which calls http functions

Flow of HTTP

Client GET /api/resource----------------|WebServer----function get() { 
							return "something" // response
						       }


HTTP Programming Models:

In 1996, Many Companies wanted to abstract http  layer to build http driven distributed apps

- J2EE -  Servlet--- Abstraction on HTTP Core apis
- ASP - Microsoft
- PHP

REST also uses exsiting http arch.

JAX-RS is spec to design REST based web app using annotations.


JAX-RS Annotations:

1.Resource Identifier
 
@Path

2.HTTP Method Binding
 
@GET,@POST,@PUT,@DELETE,@TRACE



REST Resource:

package org.cgi.getting.started;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/hello")
public class GreetingResource {
    @GET
    public String sayHello() {
        return "Hello";
    }
}

PATH Design
Responses
Negotiation

 -Content - json,xml...
 -Language
 -Encoding
..............................................................................................

HTTP Resources and Methods:
...........................

Use case :  How to design Resource with HTTP methods.


@Path:

 -Annotation can be used at class Level - Root Resource
 -Annotation can be used at method level - Nested Resource

/mainresource/subresource
  |             |
class         method

GET:
  GET is a read-only operation. 
  It is used to query the server for specific information.
  It is both an idempotent and safe operation. 

Idempotent means that 
  no matter how many times you apply the operation, the result is always the same.

Safe means that
invoking a GET does not change the state of the server at all. This means that, other
than request load, the operation will not affect the server.




Client asks that give me some thing (document,image,pdf,data).

Client sends request(instruction)----------http----------------|WebServer - will call method 							-Get Method(function)---will do some 							 io operation --read image file----
							 Write into outputstream(response)
Client will Recive Response <-----------------------------------------
    


Every Resource must have mapped at least one http method mapping.


package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }
}


Without @GET, it will cause an error.

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    
    public String getUser(){
        return "Subramanian";
    }
}

What if a uri points multiple methods having Same Request HTTP Method.

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    public String getInfo(){
        return "Info";
    }
}

Look at console
2021-08-09 13:42:48,400 WARN  [org.jbo.res.res.i18n] (executor-thread-0) RESTEASY002142: Multiple resource methods match request "GET /users". Selecting one. Matching methods: [public java.lang.String com.cgi.rest.UserResource.getUser(), public java.lang.String com.cgi.rest.UserResource.getInfo()]

Resoult would be last method result.

info

How to use @Resource at method level and class Level

package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }
}

What if @Path is not used at class level?

package com.cgi.rest;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

public class UserResource {

    @GET
    @Path("/users")
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }
}

//http://localhost:8080/users

We will get 404 -Resource Not Found Error.
..........................................................................................

PUT:
    Requests that the server store the message body sent with the request under
the location provided in the HTTP message.

It is usually modeled as an insert or update.
It is also idempotent.

POST
    POST is the only nonidempotent and unsafe operation of HTTP.

Each POST method is allowed to modify the service in a unique way.
You may or may not send information with the request.
You may or may not receive information from the response.

DELETE
  DELETE is used to remove resources. 
  It is idempotent as well.


HEAD
  HEAD is exactly like GET except that instead of returning a response body, it
returns only a response code and any headers associated with the request.

OPTIONS

 OPTIONS is used to request information about the communication options of the
resource you are interested in. 
It allows the client to determine the capabilities of a server and a resource without triggering any resource action or retrieval.


package com.cgi.rest;

import javax.ws.rs.*;

@Path("/users")
public class UserResource {

    @GET
    public String getUser(){
        return "Subramanian";
    }

    @GET
    @Path("/info")
    public String getInfo(){
        return "Info";
    }

    @PUT
    public String updateUser(){
        return "Updated";
    }

    @POST
    public String save(){
        return  "saved";
    }
    @DELETE
    public String remove(){
        return "Removed";
    }
}
..............................................................................................
				  JAX-RS Injection
.............................................................................................

What is injection?

 JAX-RS is pulling information from an HTTP request and injecting it into a java method.

We can get information after injection

-Fragement of incoming URI
-QueryString in a URI.
-The client might be sending some critical HTTP headers(request Header) or cookie values.

How to inject jax-rs annotations.

-@PathParam
-@MatrixParam
-@QueryParam
-@HeaderParam
-@FormParam
-@CookieParam
-@Context


@PathParam: 
  is used to form dynamic URI
/products/1 - here 1 is dynamic
i want to return product information having id 1.

@Path("{id}")
@Path("/products/{id}")


Use case : how to use path param , inject pathparam and read values
package com.cgi.res.params.path;


import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/library")
public class LibraryResource {

    @GET
    public String getBooks(){
        return "Books";
    }

    //library/book/123345
    @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") String isbn){
        return "Book by isbn" + isbn;
    }
   
}

Use case : if path param uri looks like different but which shares same url pattern

Note : Method Selection always based on URL Patterns not method signature


  @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") int isbn){
        return "Book by isbn" + isbn;
    }
    @GET
    @Path("/book/{authorName}")
    public String getAuthor(@PathParam("authorName") String authorName){
        return "Author - " + authorName;
    }

This code will match always the first one , second one will be skipped.

package com.cgi.res.params.path;


import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/library")
public class LibraryResource {

    @GET
    public String getBooks(){
        return "Books";
    }

    //library/book/123345
    @GET
    @Path("/book/{isbn}")
    public String getBookyById(@PathParam("isbn") int isbn){
        return "Book by isbn" + isbn;
    }
    @GET
    @Path("/book/author/{authorName}")
    public String getAuthor(@PathParam("authorName") String authorName){
        return "Author - " + authorName;
    }
}
.............................................................................................
			    Path Design using Regular Expressions
.............................................................................................

Regular expression is one of the most popular text processing patterns

https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html


The @Path template variable is not limited to a fixed string expression, we can also use regular expressions for them. The regex must be a valid expression per Java regex specs.

By default, the URI variable must match the regular expression "[^/]+?".

That means a path of one or more characters value will match, also the leading '/' is always ignored, so it's not necessary to always put a leading '/' in path variable names.

Syntax for using regex
@Path("fixedPart/{variable: regex}")

The following example restrict user name to be only of lowercase and uppercase alphanumeric characters.

@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")


package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("/users")
public class UserResource {

    /**
     *@Path("list/{userName:[a-zA-Z][a-zA-Z_0-9]*}")
     * valid urls
     * localhost:8080/users/list/Subramanian
     * localhost:8080/users/list/SUBRAMANIAN
     * localhost:8080/users/list/SUBRAM12333ANIAN
     *  @Path("list/{userName:[a-zA-Z]*}")
     *  valid urls:
     *  localhost:8080/users/list/SUBRAMANIAN
     */
    @GET
    //@Path("list/{userName:[a-zA-Z][a-zA-Z_0-9]*}")
    @Path("list/{userName:[a-zA-Z]*}")
    public String getUser(@PathParam("userName") String userName) {
        return "User Name Regex" + userName;
    }
}
.............................................................................................
				    Query Parameters
.............................................................................................

@QueryParam :
 It is used to read request parameter which was supplied via Query Strings

 GET /books?num=5
 GET /customers?start=1&size=10
package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;

@Path("/queryresource")
public class QueryParamResource {

//localhost:8080/queryresource?num=10&start=1&size=100
    @GET
    public String getQueryParam(@QueryParam("num") int num, @QueryParam("start") int start, @QueryParam("size") int size) {
        return "Query Params" + num + " " + start + " " + size;
    }
}
........................................................................
What if i have more parameters? i have to inject into method in order to access all parameters
We have short cut to read all parameters using One Object.
............................................................................................
				  Context Object
............................................................................................

Context Object represents "container". Using context object we can access many information.

Information:

javax.ws.rs.core
1.HttpHeaders
2.UriInfo
3.Request
4.HttpServletRequest - ServletRequest
5.HttpServletResponse
6.ServletConfig
7.ServletContext
8.SecurityContext
............................................................................................
                             Accssing Query Params using Context
.............................................................................................


package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.UriInfo;

@Path("/queryresource")
public class QueryParamResource {
    @GET
    public String getQueryParam(@QueryParam("num") int num, @QueryParam("start") int start, @QueryParam("size") int size) {
        return "Query Params" + num + " " + start + " " + size;
    }

    //localhost:8080/queryresource/ctx?num=10&start=1&size=100
    @GET
    @Path("ctx")
    public String getQueryParamUsingContext(@Context UriInfo uriInfo){
        String num = uriInfo.getQueryParameters().getFirst("num");
        String start =uriInfo.getQueryParameters().getFirst("start");
        String size = uriInfo.getQueryParameters().getFirst("size");
        return "Query Params using ctx " +  num + " " + start + " " + size;
    }
}
..............................................................................................
				 Matrix Parameters

Matrix Parameter is used along with Path Parameter, in order to add more values for given path.

Car Information:

/car/{make}/{model}/{year}

/car/mercedes/e55;color=black/2008
		    |
		 Matrix Parameter

To read Matrix Parameter value @MatrixParam("color") String color

package com.cgi.rest.params;

import javax.ws.rs.GET;
import javax.ws.rs.MatrixParam;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("/car/{make}")
public class CarResource {

    //localhost:8080/car/mercedes/e55;color=black/2008
    @GET
    @Path("/{model}/{year}")
    public String getCarInfo(@MatrixParam("color") String color,
                             @PathParam("make") String make,
                             @PathParam("model") String model,
                             @PathParam("year") String year
    ) {

        return "Car " + color + make + model + year;
    }
}
..............................................................................................
				Header Parameter
                                  @HeaderParam

This annotation is used to inject http request header values.
For eg : Server is interested to know or read all client http request headers
like content type,accept,language,encoding,client details....

package com.cgi.rest.params;

import org.jboss.resteasy.annotations.jaxrs.HeaderParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import java.util.Set;

@Path("/headers")
public class HeaderParamResource {

    @GET
    public String getHeaderInfo(@HeaderParam("Content-Type") String contentType ,@HeaderParam("Accept") String acceptType){
            return "Header" + contentType + " " + acceptType;
    }
    @GET
    @Path("/all")
    public String getAllHeaders(@Context HttpHeaders httpHeaders){
        //print only headers and not values - keySet returns only key portion
        httpHeaders.getRequestHeaders().keySet().forEach(header->{
            System.out.println(header);
        });
         return "all";
    }
}
.................................................................................................
				Cookie Params
.............................................................................................

if you want to read cookie and send cookie

we can use @CookieParam to read cookie value.

cookie is used to exchange information between client and server for unquie identification.


Steps:

1.Server should send cookie to the client

2.Client should send the same cookie to the server
  
From the server , if i want read cookie sent by client -@CookieParam 

package com.cgi.rest.params;

import javax.ws.rs.CookieParam;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.NewCookie;
import javax.ws.rs.core.Response;

@Path("/login")
public class CookieParamResource {

    //send cook
    @GET
    @Path("/createcookie")
    public Response createCookie(@QueryParam("userName") String userName) {
//        NewCookie cookie = new NewCookie("userName", "Subramanian");
        NewCookie cookie = new NewCookie("userName", userName);

        //send cookie to the client
        return Response.ok("cookie sent").cookie(cookie).build();
    }

    @GET
    public String getCookie(@CookieParam("userName") String userName) {
        return "Cookie Name " + userName;
    }

}
.............................................................................................
				 Sending Data via Forms
.............................................................................................


Form data can be sent to the server , via "Payload-body".

When the input request body is of the type "application/x-www-form-urlencoded" , aka html form,you can collect data into one single payload looks like an object, send to the the server.

Now server can extract form parameters from the "Payload" using @FormParam

<form method="post" action="resource/form">
   <input type="text" name="firstName">
   <input type="text" name="lastName">
</form>
We are going to use post man to send form data.


package com.cgi.rest.params;

import javax.ws.rs.FormParam;
import javax.ws.rs.POST;
import javax.ws.rs.Path;

@Path("/register")
public class RegisterationFormResource {


    @POST
    @Path("/save")
        public String save(@FormParam("firstName") String firstName, @FormParam("lastName") String lastName) {
        return "Form saved" + firstName + lastName;
    }

}
...........................................................................................
				 @DefaultValue
...........................................................................................
@DefaultValue is a parameter annotation that can be combined with any of the other @*Param
annotations to define a default value when the HTTP request item does not exits.

eg:

GET /book?num=10 

public ReturnType getBook(@QueryParam("num") int num) {


}

package com.cgi.rest.params;

import javax.ws.rs.*;

@Path("/book")
public class DefaultParamResource {

    @GET
    public String getQueryParam(@QueryParam("num") @DefaultValue("10") int num) {
        return "Query " + num;
    }

//    @GET
//    @Path("{id}")
//    public String getPathParam(@PathParam("id") @DefaultValue("100") int id) {
//        return id + "";
//    }
}
.............................................................................................
			        Resource Locators and Sub Resources
............................................................................................

Main resource:

ShoppingApp.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.Path;

@Path("/cgi/api")
public class ShoppingApp {

    @Path("/customers")
    public CustomerResource getCustomer() {
        return new CustomerResource();
    }

    @Path("/payments")
    public PaymentResource getPayment() {
        return new PaymentResource();
    }
}

CustomerResource.java
package com.cgi.rest.resourcelocators;


import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class CustomerResource {

    @GET
    public String getCustomers() {
        return "customers resource";
    }

    @GET
    @Path("{id}")
    public String getCustomerById(@PathParam("id") String id) {
        return "customers resource by id" + id;
    }
}

PaymentResource.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class PaymentResource {
    @GET
    public String getPayment() {
        return "Payment resource";
    }

    @GET
    @Path("{id}")
    public String getPayment(@PathParam("id") String id) {
        return "Payment resource by id" + id;
    }

    @Path("/creditcard")
    public CreditCardResource getCreditCard(){
          return new CreditCardResource();
    }

}

CreditCardResource.java
package com.cgi.rest.resourcelocators;

import javax.ws.rs.GET;

public class CreditCardResource {
    @GET
    public String getCreditCardDetails() {
        return "Credit Details";
    }
}
..............................................................................................

How to send data(information) to Server?

1.via Parameters - path,query,matrix,cookie,headers
2.via forms - payload(body)
3.via payloads- submit xml,json...

-Responses
-Negotation
-Exception
..............................................................................................
				   Responses

What is Response?
    
 Information + its Meta Data
 
Information can be any thing from data to static files(image,vid,docs)...

Information if it is state of the resource eg - customer,product,payment.....

As Per REST concept, Server can send any type of Format approvied by Rest spec.

eg Json,xml,html,plain text,image.......


Meta Data : data about data:
...........................

Headers - carry meta data.

Response code -  can be success,failure....
Data type(contentType/media type)- plaintext ,html,xml,json.........

.............................................................................................

RestEasy can return data using String,Domain Object,Response Object


@GET
public String getInfo(){ 
     
    return "Hello"  //Plain Text /Ascii Text
}

@GET
public Customer getCustomer(){ 
     
    return new Customer();  Object need to converted into String form(Special String types- 			    XML,JSON)
}


@GET
public Response getCustomer(){ 
     
    return Response.status.(200).ok(new Customer()).build()
       //Here you can add more and more meta information as part of Response
				  
}
............................................................................................

If you are getting the error like below, when you access an resource

Could not find MessageBodyWriter for response object of type: com.cgi.rest.responses.User of media type:application/octet-stream

Server says, hey i am not able to process your(client) request , because i dont know how to convert User into something client understand

Quarkus is opionied framework, which looks up converter(Object to String) in the classpath.
Quarkus offers an extension(dependency) for converting Object to String(JSON).

pom.xml
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy-jsonb</artifactId>
    </dependency>


if you want to send xml as response

<dependency>
     <groupId>io.quarkus</groupId>
     <artifactId>quarkus-resteasy-jaxb</artifactId>
</dependency>

package com.cgi.rest.responses;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/responses")
public class ResponseResources {

    @GET
    @Path("/plain")
    public String sendPlainResponse() {
        return "Hello";
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    public User sendUserJSONResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Path("/user/xml")
    @Produces(MediaType.APPLICATION_XML)
    public User sendUserXmlResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }
    
    

}
..............................................................................................
Response:

Response class is abstract class contains two category of api

public abstract Object getEntity();
public abstract int getStatus();


Builder Class:

public static ResponseBuilder status(int status)
public static ResponseBuilder ok()
public static ResponseBuilder ok(Object entity)
public static ResponseBuilder created()
public static ResponseBuilder accepted()
public static ResponseBuilder noContent()
etc..


Builder is a design pattern through which you can chain methods and create instances on fly.

"hello".trim().toUppercase().toLowercase() - builder pattern


How to create Response Object?

javax.ws.rs.core.Response  class is abstract class, we cant create object directly, only possible via builder

Resonse.ok().build() -returns Response
 

package com.cgi.rest.responses;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/responses")
public class ResponseResources {

    @GET
    @Path("/plain")
    public String sendPlainResponse() {
        return "Hello";
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    public User sendUserJSONResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Path("/user/xml")
    @Produces(MediaType.APPLICATION_XML)
    public User sendUserXmlResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public Response sendResponse() {
        //Type of data to be sent
        return Response
                .ok("Hello Response")
                .header("myheader", "myheadervalue")
                .build();
    }


}
................................................................................................				Status Codes And RestFul Api Design
..............................................................................................
Status Code : 100 to 500

1XX Information Responses

100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2XX Success

200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used

3XX Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
306 Switch Proxy
307 Temporary Redirect
308 Permanent Redirect

4XX Client errors

400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 URI Too Long
415 Unsupported Media Type
416 Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
420 Method Failure
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
451 Unavailable For Legal Reasons

5XX Server errors
500 Internal Server error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 gateway Timeout
505 Http version not supported
506 Varient Also negotiate
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required


.............................................................................................
package com.cgi.rest.responses;

import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/responses")
public class ResponseResources {

    @GET
    @Path("/plain")
    public String sendPlainResponse() {
        return "Hello";
    }

    @GET
    @Path("/user")
    @Produces(MediaType.APPLICATION_JSON)
    public User sendUserJSONResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Path("/user/xml")
    @Produces(MediaType.APPLICATION_XML)
    public User sendUserXmlResponse() {
        User user = new User(1, "admin", "admin");
        return user;
    }

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public Response sendResponse() {
        //Type of data to be sent

        //OK -200 status - success
//        return Response
//                .ok("Hello Response")
//                .header("myheader", "myheadervalue")
//                .build();

//        return Response
//                .status(200)
//                .entity("Hello Response!!!")
//                .header("myheader", "myheadervalue")
//                .build();
//        return Response
//                .status(Response.Status.OK)
//                .entity("Hello Response!!!")
//                .header("myheader", "myheadervalue")
//                .build();
        return Response
                .status(Response.Status.OK)
                .entity("Hello Response!!!")
                .header("myheader", "myheadervalue")
                .build();
    }
    //Some Status code
    @POST
    public Response save(){
        return Response.status(201).entity("Saved").build();
    }


}
..............................................................................................
				  Negoation
..............................................................................................

What is Negoation?
 Agreeement between server and client what they can serve.

if client asks server that give me xml, means the server should able to give xml, if not it will give  response- not able to process your.

Content negotiation allows for an HTTP server to respond to different types of clients.

Many modern clients expect a JSON response, but there may be a need to format responses differently, maybe XML for older clients or a binary format for newer ones.


If the server is unable to provide the desired format, it will respond with a status code of 406, ‚ÄúNot Acceptable.‚Äù

Types of Negoation:

1.Content-Negotation
2.Language Negoation
3.Encoding Negoation


How to implement  Negotation?

Via Headers


Accept-*

Content Negotation
Accept: application/json,application/xml;

Language Negotation:
Accept-Language: fr

Encoding Negotation:
Accept-Encoding : gzip,deflate
..............................................................................................

Negotitation is just like a dialog between client and server.


At a high level, the conversation looks like this:

Client:
Hey Server!
I‚Äôd like to look at https://api.example.com/user/123.
I need your response in JSON.

	Server:
No Problem Client! Here is that response‚Ä¶‚Äã


Client:
Hey Server! I need https://api.example.com/user/123, preferably in JSON!
But, üò© I‚Äôll take XML if that‚Äôs all you have.
I also need the info in English or French.
Oh, please zip up the contents too.

GET /user/123 HTTP/1.1
Accept: application/json,application/xml;q=0.9
Accept-Encoding: gzip
Accept-Language: en,fr
Host: api.example.com
User-Agent: Client/2.0


Server:
Hey Client!
All I have is XML (sorry about that), the response is in English,
and I was able to zip it; here you go‚Ä¶‚Äã

                                        HTTP/1.1 200 OK
                                        Content-Type: application/xml
                                        Content-Encoding: gzip
                                        Content-Language: en

                                        <user id="123">
                                          ...
                                        </user>

..............................................................................................
Negotiation is bi directional.

Client ask with help of "Accept -*" Headers, Server will resonse with "Content-*" Headers

Content Negotation:

package com.cgi.rest.negotiation;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {

    //ContentNegation
    /**
     * GET  /negotiation/content Accept:application/json or Accept:application/xml
     */
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin", "admin");
        return Response.ok(user).build();
    }

}
.............................................................................................

How to send Data from the client to server (in the form of string(json,xml),binary?

How server negotiate with client to accept data?

Payload-body

package com.cgi.rest.negotiation;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {

      /**
     * POST negotation/create
     * body
     * content-type : Application/json / Application/xml
     */
    @POST
    @Path("/create")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response create(User user) {
        System.out.println(user);
        return Response.status(201).entity("Created").build();
    }


}
..............................................................................................						HTTP encoding
.............................................................................................

What is Content Encoding?

 if Server sends data, it can send directly

Compression Algorthim:

1.gzip
2.deflate

How to enable compression algorithm in quarkus?

application.properties
#quarkus.http.enable-compression=true
#quarkus.resteasy.gzip.enabled=true
#quarkus.resteasy.gzip.max-input=10M


If you want to compress everything then we recommended that you use the quarkus.http.enable-compression=true setting instead to globally enable compression support.


Response would be:

content-encoding:gzip
content-length:64
..............................................................................................

					Language Negotitation
..............................................................................................

if you ask the server that give me data in fr.

Accept-language : de /en

package com.cgi.rest.negotiation;

import org.jboss.resteasy.annotations.GZIP;

import javax.ws.rs.*;
import javax.ws.rs.core.*;
import java.util.List;
import java.util.Locale;

@Path("/negotiation")
public class ContentNegotiationResource {

    // GET /negotiation/lang 
    //Accept-language : en

    @Path("/lang")
    @GET
    public Response getLang(@Context Request request) {
        List<Variant> variants = Variant.VariantListBuilder
                .newInstance()
                .languages(Locale.ENGLISH, Locale.GERMAN)
                .build();
        Variant variant = request.selectVariant(variants);
        if (variant == null) {
            return Response.notAcceptable(variants).build();
        }
        String language = variant.getLanguageString();
        return Response.ok(language)
                .header(HttpHeaders.CONTENT_LANGUAGE, language)
                .build();
    }


}
..............................................................................................
					Exception Handling
..............................................................................................

Errors can be reported to a client either by creating and returning the appropriate
Response object or by throwing an exception.

Response Types:

1.SUCCESS Response
2.ERROR Response

How to handle / Convert ERRORS/Exceptions into HTTP Response Object?

 public Response getResponse(){

     return Response.ok().build();
 }

According to Application, Exception can be

1.System Exception :
  Exception thrown by jvm - NumberFormat,NullPointerException,ClassCastException.

2.Application Exception
   
  UserNotFoundException
  PasswordMissMatchException
  ...
public boolean validate(){

  if(passwordmatch){


  }
  else{ 
       throw new PasswordMismatchException("password does not match");
  } 
}
JAX-RS also provides the javax.ws.rs.WebApplicationException. 
This can be thrown by application code and automatically processed by JAX-RS without
having to write an explicit mapper.

WebApplicationException can be converted into Response Object.

Thrown exceptions are handledby the JAX-RS runtime if you have registered an exception mapper. 
Exception mappers can convert an exception to an HTTP response. 
If the thrown exception is not handledby a mapper, it is propagated and handled by the container (i.e., servlet) JAX-RS is running within.

How to write biz exception in jax rs?


package com.cgi.rest.exceptionhandling;

import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;

@Path("/myerrros")
public class ErrorResource {

    @GET
    @Path("{id}")
    public Response getResponse(@PathParam("id") String id) {
        if (id.equals("100")) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return Response.ok("Sucess" + id).build();
    }
}

When you run this code with "localhost:8080/myerrros/100"

Server will show exception like below?
rs.WebApplicationException: HTTP 404 Not Found
        at com.cgi.rest.exceptionhandling.ErrorResource.getResponse(ErrorResource.java:17)
        at com.cgi.rest.exceptionhandling.ErrorResource_Subclass.getResponse$$superforward1(ErrorResource_Subclass.zig:94)
        at com.cgi.rest.exceptionhandling.ErrorResource_Subclass$$function$$1.apply(ErrorResource_Subclass$$function$$1.zig:33)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:54)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:49)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(InvocationInterceptor_Bean.zig:521)
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:41)
        at io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)
        at com.cgi.rest.exceptionhandling.ErrorResource_Subclass.getResponse(ErrorResource_Subclass.zig:158)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)


how to convert this error into response and send to client?

package com.cgi.rest.exceptionhandling;

import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;

@Path("/myerrros")
public class ErrorResource {

    @GET
    @Path("{id}")
    public Response getResponse(@PathParam("id") String id) {
        if (id.equals("100")) {
            throw new WebApplicationException("Id " + id + "Not Found");
        }
        return Response.ok("Sucess" + id).build();
    }
}
.............................................................................................
				Context and Dependency Injection
					(CDI)
..........................................................................................

Object Composition: - HAS -A relationship

package com.cgi.hasa;

public class Product {
    private int productId;
    private String name;

    public Product() {
    }

    @Override
    public String toString() {
        return "Product{" +
                "productId=" + productId +
                ", name='" + name + '\'' +
                '}';
    }

    public Product(int productId, String name) {
        this.productId = productId;
        this.name = name;
    }

    public int getProductId() {
        return productId;
    }

    public void setProductId(int productId) {
        this.productId = productId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package com.cgi.hasa;

public class Order {
    private int orderId;
    private double orderValue;
    //has-a - dependancy
    private Product product;

    public Order() {
    }

    public Order(Product product) {
        this.product = product;
    }

    @Override
    public String toString() {
        return "Order{" +
                "orderId=" + orderId +
                ", orderValue=" + orderValue +
                ", product=" + product +
                '}';
    }

    public Order(int orderId, double orderValue, Product product) {
        this.orderId = orderId;
        this.orderValue = orderValue;
        this.product = product;
    }

    public int getOrderId() {
        return orderId;
    }

    public void setOrderId(int orderId) {
        this.orderId = orderId;
    }

    public double getOrderValue() {
        return orderValue;
    }

    public void setOrderValue(double orderValue) {
        this.orderValue = orderValue;
    }

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }
}

package com.cgi.hasa;

public class Main {
    public static void main(String[] args) {
        //Steps :
        //1.create objects
        //2.Link the objects
        Product product = new Product(1,"Book");
        Order order = new Order(1,1000,product);
        System.out.println(order);
    }
}

Here , what if there are more objects we need to create, and link them accordingly.

Product product = new Product(1,"Book");
Order order = new Order(1,1000,product);

Two complexity in enterprise computing:

1.creating objects
2.linking objects 

How to deal this complixity?

2000 ,Rod Johnson  who identified this problem - book - j2ee one on one design and developement.
   -how to reduce creating objects and links

He thought to write some automation software? he introduced a design pattern
 -IOC -  Inversion of Control.

What is IOC?

inversion - do opposit
of control -management

Developer has control for creating objects and link them -  we have to invert this task from developer
 
According to ioc, dont create object and link via coding. 

Who has to take care?
  -Automation software  ---- IOC Container.

Based on IOC Container idea,Rod who developed a framework in spring season "Spring Framework".

Spring Framwork abstracts away "creating objects and linking them from the developer".
............................................................................................. 

What is dependency Injection?
  
  Dependency -Object
  Injection - Injecting into Object

Objects are created by containers, available to programers for use.
..............................................................................................
How to get dependencies inside program? or How depedency Injection is happening?

-dependencies are injected via setter methods
-dependencies are injected via constructor methods
-dependencies are injected via "fiedls"  -J2EE CDI 
..............................................................................................
Core Concepts:

1.Bean :
  

What is Bean?
   
  Bean is terminallogy coined by SUN Micro System to name java object.

Object vs Bean?

 -Same but Bean has some special characteristics  which was proposed by SUN micro system via 
"Java Bean Spec"

It is java class, based Java Bean standards
 	-class should be public
 	-properties should be private
 	-set and get methods - Accessors and mutators
	-constructors

Why Bean Spec?
  - in order to standarize the java dev process- Coding Standards.

Many frameworks,containers,tools,compilers follow the bean standards only
eg: spring framework,ecplise,idea....

..............................................................................................

class Order {

}

class MyServlet extends HttpServlet{

}
MyServlet my=new MyServlet(); 
  -Extra features will be injected by container
    -lifecycles
    -thread managment
    -attching with http protocal

Order order=new Order()
..............................................................................................

Bean Types:

1.POJO Bean
   eg : order
2.Container Managed Bean

 - Container provides basic services
     - lifecycle callabacks,intercepters
     - creation,destroying
     - bean depdency lookup

Why Container Managed Bean?
   -Dev can focus only Applicaition logic...
............................................................................................
                                 Quarkus and Dependency Injection
............................................................................................

Quarkus uses MicroProfile CDI2.0 Spec, which intern refers 
  JSR 365: Contexts and Dependency Injection for JavaTM 2.0.

How Quarkus implements this spec?
 Quarkus ArC is a build-time oriented dependency injection based on CDI 2.0. 

.............................................................................................

                CDI is built on the concept of  "loose coupling,String Typing" 


                         Beans are loosely coupled but strongly typed


Apis in cdi:

1.javax.inject
2.javax.enterprise.inject - core di apis
3.javax.enterprise.context - scope and contextuaal apis
4.javax.enterprise.events -  publishing events and listening events-  container wide event driven programming
5.javax.enterprise.util
6.javax.interceptor

Common Annoations:

1.@Inject  
2.@Qualifer
3.LifeCycle of Bean
   @ApplicationScoped
   @SessionScoped
   @RequestScoped
   @SingleTon
 
4.@Observes - event listner
..............................................................................................

DI : Simple


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;

//bean
@ApplicationScoped
public class HelloService {

      public String sayHello(){
           return "Hello Service Bean";
      }
}



package com.cgi;

import com.cgi.di.HelloService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/hello")
public class HelloResource {

    @Inject
    HelloService helloService;

    @GET
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}

............................................................................................
				Bean Creation Exception-UnsatisfiedResolutionException


avax.enterprise.inject.UnsatisfiedResolutionException: Unsatisfied dependency for type com.cgi.di.HelloService and qualifiers [@Default]
	- java member: com.cgi.HelloResource#helloService
	- declared on CLASS bean [types=[java.lang.Object, com.cgi.HelloResource], qualifiers=[@Default, @Any], target=com.cgi.HelloResource]
	at io.quarkus.arc.processor.Beans.resolveInjectionPoint(Beans.java:492)
	at io.quarkus.arc.processor.BeanInfo.init(BeanInfo.java:463)


This exception is thrown when bean is not created -  
  due to 
    -no bean class  not present in the class path
    -you may forgot to annotate using lifecycle annotations -@ApplicationScoped...


eg:
public class HelloService {

      public String sayHello(){
           return "Hello Service Bean";
      }
}
 @Inject
 HelloService helloService;


.............................................................................................
                              Types of Injection in Quarkus  -Inection Points

1.Field Injection
2.Setter Injection
3.Constructor injection



1.Field Injection
1. @Inject
    HelloService helloService;


2.Setter Injection

    HelloService helloService;

    @Inject
    public void setHelloService(HelloService helloService) {
        this.helloService = helloService;
    }
3.Constructor injection

  @Inject
    public HelloResource(HelloService helloService) {
        this.helloService = helloService;
    }
 without @Inject annotation is also fine
   public HelloResource(HelloService helloService) {
        this.helloService = helloService;
    }
..............................................................................................
			   Service has its dependencies
..............................................................................................


 Resource-----Service-----Utility Bean
 Resource -----Service----Repository


interface:
package com.cgi.di;

public interface NumberGenerator {
    //Generate ISBN Number
    String generateNumber();
}

Implementation
package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import java.util.Random;

@ApplicationScoped
public class IsbnGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "15-87654" + Math.abs(new Random().nextInt());
    }
}


package com.cgi.di;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

@ApplicationScoped
public class BookService {

    //Inject interface
    @Inject
    NumberGenerator numberGenerator;

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}

package com.cgi;

import com.cgi.di.BookService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/books")
public class BookResource {

    @Inject
    BookService bookService;

    @GET
    public Response createBook(){
        return Response.ok(bookService.createBook()).build();
    }
}

























 



